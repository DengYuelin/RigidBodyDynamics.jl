<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>7. Rigorous error bounds using IntervalArithmetic Â· RigidBodyDynamics.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link href="../../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>RigidBodyDynamics.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../../">Home</a></li><li><span class="toctext">Tutorials</span><ul><li><a class="toctext" href="../../1. Quickstart - double pendulum/1. Quickstart - double pendulum/">1. Quickstart - double pendulum</a></li><li><a class="toctext" href="../../2. Closed-loop simulation and visualization/2. Closed-loop simulation and visualization/">2. Closed-loop simulation and visualization</a></li><li><a class="toctext" href="../../3. Four-bar linkage/3. Four-bar linkage/">3. Four-bar linkage</a></li><li><a class="toctext" href="../../4. Jacobian IK and Control/4. Jacobian IK and Control/">4. Jacobian IK and Control</a></li><li><a class="toctext" href="../../5. Derivatives and gradients using ForwardDiff/5. Derivatives and gradients using ForwardDiff/">5. Derivatives and gradients using ForwardDiff</a></li><li><a class="toctext" href="../../6. Symbolics using SymPy/6. Symbolics using SymPy/">6. Symbolics using SymPy</a></li><li class="current"><a class="toctext" href>7. Rigorous error bounds using IntervalArithmetic</a><ul class="internal"><li><a class="toctext" href="#Floating-point-error-1">Floating-point error</a></li><li><a class="toctext" href="#Accuracy-of-RigidBodyDynamics.jl&#39;s-mass_matrix-1">Accuracy of RigidBodyDynamics.jl&#39;s <code>mass_matrix</code></a></li><li><a class="toctext" href="#Rigorous-(worst-case)-uncertainty-propagation-1">Rigorous (worst-case) uncertainty propagation</a></li></ul></li></ul></li><li><span class="toctext">Library</span><ul><li><a class="toctext" href="../../../spatial/">Spatial vector algebra</a></li><li><a class="toctext" href="../../../joints/">Joints</a></li><li><a class="toctext" href="../../../rigidbody/">Rigid bodies</a></li><li><a class="toctext" href="../../../mechanism/">Mechanism</a></li><li><a class="toctext" href="../../../mechanismstate/">MechanismState</a></li><li><a class="toctext" href="../../../algorithms/">Kinematics/dynamics algorithms</a></li><li><a class="toctext" href="../../../customcollections/">Custom collection types</a></li><li><a class="toctext" href="../../../caches/">Cache types</a></li><li><a class="toctext" href="../../../simulation/">Simulation</a></li><li><a class="toctext" href="../../../urdf/">URDF parsing and writing</a></li></ul></li><li><a class="toctext" href="../../../benchmarks/">Benchmarks</a></li></ul></nav><article id="docs"><header><nav><ul><li>Tutorials</li><li><a href>7. Rigorous error bounds using IntervalArithmetic</a></li></ul><a class="edit-page" href="https://github.com/JuliaRobotics/RigidBodyDynamics.jl/blob/master/examples/7. Rigorous error bounds using IntervalArithmetic/7. Rigorous error bounds using IntervalArithmetic.jl"><span class="fa">ï‚›</span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>7. Rigorous error bounds using IntervalArithmetic</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id=".-Rigorous-error-bounds-using-IntervalArithmetic-1" href="#.-Rigorous-error-bounds-using-IntervalArithmetic-1">7. Rigorous error bounds using IntervalArithmetic</a></h1><h2><a class="nav-anchor" id="Floating-point-error-1" href="#Floating-point-error-1">Floating-point error</a></h2><p>In computers, real numbers are commonly approximated using floating-point numbers, such as Julia&#39;s <code>Float64</code>. Unfortunately, not all real numbers can be exactly represented as a finite-size floating-point number, and the results of operations on floating-point numbers can only approximate the results of applying the operation to a true real number. This results in peculiarities like:</p><div><pre><code class="language-julia">2.6 - 0.7 - 1.9</code></pre><pre><code class="language-none">2.220446049250313e-16</code></pre></div><p>IntervalArithmetic.jl can be used to quantify floating point error, by computing <em>rigorous</em> worst-case bounds on floating point error, within which the true result is <em>guaranteed</em> to lie.</p><div><pre><code class="language-julia">using IntervalArithmetic</code></pre><pre><code class="language-none">  Updating registry at `~/.julia/registries/General`
  Updating git-repo `https://github.com/JuliaRegistries/General.git`
[?25l[2K[?25h Installed ErrorfreeArithmetic â”€ v0.3.2
 Installed SetRounding â”€â”€â”€â”€â”€â”€â”€â”€â”€ v0.2.0
 Installed CRlibm â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ v0.7.1
 Installed IntervalArithmetic â”€â”€ v0.15.2
 Installed FastRounding â”€â”€â”€â”€â”€â”€â”€â”€ v0.2.0
  Building CRlibm â†’ `~/.julia/packages/CRlibm/2S9DB/deps/build.log`</code></pre></div><p>IntervalArithmetic.jl provides the <code>Interval</code> type, which stores an upper and a lower bound:</p><div><pre><code class="language-julia">i = Interval(1.0, 2.0)</code></pre><pre><code class="language-none">[1, 2]</code></pre></div><div><pre><code class="language-julia">dump(i)</code></pre><pre><code class="language-none">IntervalArithmetic.Interval{Float64}
  lo: Float64 1.0
  hi: Float64 2.0</code></pre></div><p>IntervalArithmetic.jl provides overloads for most common Julia functions that take these bounds into account. For example:</p><div><pre><code class="language-julia">i + i</code></pre><pre><code class="language-none">[2, 4]</code></pre></div><div><pre><code class="language-julia">sin(i)</code></pre><pre><code class="language-none">[0.84147, 1]</code></pre></div><p>Note that the bounds computed by IntervalArithmetic.jl take floating point error into account. Also note that a given real number, once converted to (approximated by) a floating-point number may not be equal to the original real number. To rigorously construct an <code>Interval</code> that contains a given real number as an input, IntervalArithmetic.jl provides the <code>@interval</code> macro:</p><div><pre><code class="language-julia">i = @interval(2.9)
i.lo === i.hi</code></pre><pre><code class="language-none">false</code></pre></div><div><pre><code class="language-julia">dump(i)</code></pre><pre><code class="language-none">IntervalArithmetic.Interval{Float64}
  lo: Float64 2.9
  hi: Float64 2.9000000000000004</code></pre></div><p>Compare this to</p><div><pre><code class="language-julia">i = Interval(2.9)
i.lo === i.hi</code></pre><pre><code class="language-none">true</code></pre></div><div><pre><code class="language-julia">dump(i)</code></pre><pre><code class="language-none">IntervalArithmetic.Interval{Float64}
  lo: Float64 2.9
  hi: Float64 2.9</code></pre></div><p>As an example, consider again the peculiar result from before, now using interval arithmetic:</p><div><pre><code class="language-julia">i = @interval(2.6) - @interval(0.7) - @interval(1.9)</code></pre><pre><code class="language-none">[-6.66134e-16, 2.22045e-16]</code></pre></div><p>showing that the true result, <code>0</code>, is indeed in the guaranteed interval, and indeed:</p><div><pre><code class="language-julia">using Test
@test (2.6 - 0.7 - 1.9) âˆˆ i</code></pre><pre><code class="language-none">Test Passed</code></pre></div><h2><a class="nav-anchor" id="Accuracy-of-RigidBodyDynamics.jl&#39;s-mass_matrix-1" href="#Accuracy-of-RigidBodyDynamics.jl&#39;s-mass_matrix-1">Accuracy of RigidBodyDynamics.jl&#39;s <code>mass_matrix</code></a></h2><p>Let&#39;s use IntervalArithmetic.jl to establish rigorous bounds on the accuracy of the accuracy of the <code>mass_matrix</code> algorithm for the Acrobot (double pendulum) in a certain configuration. Let&#39;s get started.</p><div><pre><code class="language-julia">using RigidBodyDynamics</code></pre></div><p>We&#39;ll create a <code>Mechanism</code> by parsing the Acrobot URDF, passing in <code>Interval{Float64}</code> as the type used to store the parameters (inertias, link lengths, etc.) of the mechanism. Note that the parameters parsed from the URDF are treated as floating point numbers (i.e., like <code>Interval(2.9)</code> instead of <code>@interval(2.9)</code> above).</p><div><pre><code class="language-julia">const T = Interval{Float64}
srcdir = dirname(pathof(RigidBodyDynamics))
urdf = joinpath(srcdir, &quot;..&quot;, &quot;test&quot;, &quot;urdf&quot;, &quot;Acrobot.urdf&quot;)
const mechanism = parse_urdf(urdf; scalar_type=T)
state = MechanismState(mechanism)</code></pre><pre><code class="language-none">MechanismState{IntervalArithmetic.Interval{Float64}, IntervalArithmetic.Interval{Float64}, IntervalArithmetic.Interval{Float64}, â€¦}(â€¦)</code></pre></div><p>Let&#39;s set the initial joint angle of the shoulder joint to the smallest <code>Interval{Float64}</code> containing the real number <span>$1$</span>, and similarly for the elbow joint:</p><div><pre><code class="language-julia">shoulder, elbow = joints(mechanism)
set_configuration!(state, shoulder, @interval(1))
set_configuration!(state, elbow, @interval(2));</code></pre></div><p>And now we can compute the mass matrix as normal:</p><div><pre><code class="language-julia">M = mass_matrix(state)</code></pre><pre><code class="language-none">2Ã—2 LinearAlgebra.Symmetric{IntervalArithmetic.Interval{Float64},Array{IntervalArithmetic.Interval{Float64},2}}:
 [1.8307, 1.83071]     [0.913853, 0.913854]
 [0.913853, 0.913854]  [1.32999, 1.33001]</code></pre></div><p>Woah, those bounds look pretty big. RigidBodyDynamics.jl must not be very accurate! Actually, things aren&#39;t so bad; the issue is just that IntervalArithmetic.jl isn&#39;t kidding when it comes to guaranteed bounds, and that includes printing the numbers in shortened form. Here are the lengths of the intervals:</p><div><pre><code class="language-julia">err = map(x -&gt; x.hi - x.lo, M)</code></pre><pre><code class="language-none">2Ã—2 Array{Float64,2}:
 4.21885e-15  5.10703e-15
 5.10703e-15  6.66134e-15</code></pre></div><div><pre><code class="language-julia">@test maximum(abs, err) â‰ˆ 0 atol = 1e-14</code></pre><pre><code class="language-none">Test Passed</code></pre></div><h2><a class="nav-anchor" id="Rigorous-(worst-case)-uncertainty-propagation-1" href="#Rigorous-(worst-case)-uncertainty-propagation-1">Rigorous (worst-case) uncertainty propagation</a></h2><p>IntervalArithmetic.jl can also be applied to propagate uncertainty in a rigorous way when the inputs themselves are uncertain. Consider for example the case that we only know the joint angles up to <span>$\pm 0.05$</span> radians:</p><div><pre><code class="language-julia">set_configuration!(state, shoulder, @interval(0.95, 1.05))
set_configuration!(state, elbow, @interval(1.95, 2.05));</code></pre></div><p>and let&#39;s compute bounds on the center of mass position:</p><div><pre><code class="language-julia">center_of_mass(state)</code></pre><pre><code class="language-none">Point3D in &quot;world&quot;: IntervalArithmetic.Interval{Float64}[[-0.770193, -0.630851], [0.199999, 0.200001], [0.0167304, 0.163822]]</code></pre></div><p>Note that the bounds on the <span>$y$</span>-coordinate are very tight, since our mechanism only lives in the <span>$x$</span>-<span>$z$</span> plane.</p><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p><footer><hr/><a class="previous" href="../../6. Symbolics using SymPy/6. Symbolics using SymPy/"><span class="direction">Previous</span><span class="title">6. Symbolics using SymPy</span></a><a class="next" href="../../../spatial/"><span class="direction">Next</span><span class="title">Spatial vector algebra</span></a></footer></article></body></html>
