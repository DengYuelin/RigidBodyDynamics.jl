<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Kinematics/dynamics algorithms · RigidBodyDynamics.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/highlightjs/default.css" rel="stylesheet" type="text/css"/><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>RigidBodyDynamics.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Home</a></li><li><a class="toctext" href="quickstart.html">Quick start guide</a></li><li><a class="toctext" href="spatial.html">Spatial vector algebra</a></li><li><a class="toctext" href="joints.html">Joints</a></li><li><a class="toctext" href="rigidbody.html">Rigid bodies</a></li><li><a class="toctext" href="mechanism.html">Mechanism</a></li><li><a class="toctext" href="mechanismstate.html">MechanismState</a></li><li class="current"><a class="toctext" href="algorithms.html">Kinematics/dynamics algorithms</a><ul class="internal"><li><a class="toctext" href="#Index-1">Index</a></li><li><a class="toctext" href="#The-DynamicsResult-type-1">The <code>DynamicsResult</code> type</a></li><li><a class="toctext" href="#Functions-1">Functions</a></li></ul></li><li><a class="toctext" href="simulation.html">Simulation</a></li><li><a class="toctext" href="benchmarks.html">Benchmarks</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="algorithms.html">Kinematics/dynamics algorithms</a></li></ul><a class="edit-page" href="https://github.com/tkoolen/RigidBodyDynamics.jl/tree/6f579338a933afb6a32ed7c8113e92a8f4db5772/docs/src/algorithms.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Kinematics/dynamics algorithms</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Algorithms-1" href="#Algorithms-1">Algorithms</a></h1><h2><a class="nav-anchor" id="Index-1" href="#Index-1">Index</a></h2><ul><li><a href="algorithms.html#RigidBodyDynamics.DynamicsResult"><code>RigidBodyDynamics.DynamicsResult</code></a></li><li><a href="algorithms.html#RigidBodyDynamics.center_of_mass-Tuple{RigidBodyDynamics.MechanismState}"><code>RigidBodyDynamics.center_of_mass</code></a></li><li><a href="algorithms.html#RigidBodyDynamics.center_of_mass-Tuple{RigidBodyDynamics.MechanismState,Any}"><code>RigidBodyDynamics.center_of_mass</code></a></li><li><a href="algorithms.html#RigidBodyDynamics.dynamics!"><code>RigidBodyDynamics.dynamics!</code></a></li><li><a href="algorithms.html#RigidBodyDynamics.dynamics!"><code>RigidBodyDynamics.dynamics!</code></a></li><li><a href="algorithms.html#RigidBodyDynamics.dynamics_bias!"><code>RigidBodyDynamics.dynamics_bias!</code></a></li><li><a href="algorithms.html#RigidBodyDynamics.geometric_jacobian-Tuple{RigidBodyDynamics.MechanismState{X,M,C},RigidBodyDynamics.Graphs.TreePath{RigidBodyDynamics.RigidBody{M},RigidBodyDynamics.Joint{M}}}"><code>RigidBodyDynamics.geometric_jacobian</code></a></li><li><a href="algorithms.html#RigidBodyDynamics.geometric_jacobian!-Tuple{RigidBodyDynamics.GeometricJacobian,RigidBodyDynamics.MechanismState,RigidBodyDynamics.Graphs.TreePath}"><code>RigidBodyDynamics.geometric_jacobian!</code></a></li><li><a href="algorithms.html#RigidBodyDynamics.geometric_jacobian!-Tuple{RigidBodyDynamics.GeometricJacobian,RigidBodyDynamics.MechanismState,RigidBodyDynamics.Graphs.TreePath,RigidBodyDynamics.Transform3D}"><code>RigidBodyDynamics.geometric_jacobian!</code></a></li><li><a href="algorithms.html#RigidBodyDynamics.geometric_jacobian!-Tuple{RigidBodyDynamics.GeometricJacobian,RigidBodyDynamics.MechanismState,RigidBodyDynamics.Graphs.TreePath,Any}"><code>RigidBodyDynamics.geometric_jacobian!</code></a></li><li><a href="algorithms.html#RigidBodyDynamics.gravitational_potential_energy-Tuple{RigidBodyDynamics.MechanismState{X,M,C}}"><code>RigidBodyDynamics.gravitational_potential_energy</code></a></li><li><a href="algorithms.html#RigidBodyDynamics.inverse_dynamics"><code>RigidBodyDynamics.inverse_dynamics</code></a></li><li><a href="algorithms.html#RigidBodyDynamics.inverse_dynamics!"><code>RigidBodyDynamics.inverse_dynamics!</code></a></li><li><a href="algorithms.html#RigidBodyDynamics.mass-Tuple{RigidBodyDynamics.Mechanism}"><code>RigidBodyDynamics.mass</code></a></li><li><a href="algorithms.html#RigidBodyDynamics.mass_matrix-Tuple{RigidBodyDynamics.MechanismState{X,M,C}}"><code>RigidBodyDynamics.mass_matrix</code></a></li><li><a href="algorithms.html#RigidBodyDynamics.mass_matrix!-Tuple{Symmetric{C,Array{C,2}},RigidBodyDynamics.MechanismState{X,M,C}}"><code>RigidBodyDynamics.mass_matrix!</code></a></li><li><a href="algorithms.html#RigidBodyDynamics.momentum_matrix-Tuple{RigidBodyDynamics.MechanismState}"><code>RigidBodyDynamics.momentum_matrix</code></a></li><li><a href="algorithms.html#RigidBodyDynamics.momentum_matrix!-Tuple{RigidBodyDynamics.MomentumMatrix,RigidBodyDynamics.MechanismState}"><code>RigidBodyDynamics.momentum_matrix!</code></a></li><li><a href="algorithms.html#RigidBodyDynamics.momentum_matrix!-Tuple{RigidBodyDynamics.MomentumMatrix,RigidBodyDynamics.MechanismState,RigidBodyDynamics.Transform3D}"><code>RigidBodyDynamics.momentum_matrix!</code></a></li><li><a href="algorithms.html#RigidBodyDynamics.momentum_matrix!-Tuple{RigidBodyDynamics.MomentumMatrix,RigidBodyDynamics.MechanismState,Any}"><code>RigidBodyDynamics.momentum_matrix!</code></a></li><li><a href="algorithms.html#RigidBodyDynamics.relative_acceleration-Tuple{RigidBodyDynamics.MechanismState,RigidBodyDynamics.RigidBody,RigidBodyDynamics.RigidBody,AbstractArray{T,1}}"><code>RigidBodyDynamics.relative_acceleration</code></a></li><li><a href="algorithms.html#RigidBodyDynamics.subtree_mass-Tuple{RigidBodyDynamics.RigidBody{T},RigidBodyDynamics.Mechanism{T}}"><code>RigidBodyDynamics.subtree_mass</code></a></li></ul><h2><a class="nav-anchor" id="The-DynamicsResult-type-1" href="#The-DynamicsResult-type-1">The <code>DynamicsResult</code> type</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.DynamicsResult" href="#RigidBodyDynamics.DynamicsResult"><code>RigidBodyDynamics.DynamicsResult</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-julia">type DynamicsResult{M&lt;:Number, T&lt;:Number}</code></pre><p>Stores variables related to the dynamics of a <code>Mechanism</code>, e.g. the <code>Mechanism</code>&#39;s mass matrix and joint acceleration vector.</p><p>Type parameters:</p><ul><li><p><code>M</code>: the scalar type of the <code>Mechanism</code>.</p></li><li><p><code>T</code>: the scalar type of the dynamics-related variables.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/tkoolen/RigidBodyDynamics.jl/tree/6f579338a933afb6a32ed7c8113e92a8f4db5772/src/dynamics_result.jl#L1">source</a><br/></section><h2><a class="nav-anchor" id="Functions-1" href="#Functions-1">Functions</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.center_of_mass-Tuple{RigidBodyDynamics.MechanismState,Any}" href="#RigidBodyDynamics.center_of_mass-Tuple{RigidBodyDynamics.MechanismState,Any}"><code>RigidBodyDynamics.center_of_mass</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">center_of_mass(state, itr)
</code></pre><p>Compute the center of mass of an iterable subset of a <code>Mechanism</code>&#39;s bodies in the given state. Ignores the root body of the mechanism.</p></div><a class="source-link" target="_blank" href="https://github.com/tkoolen/RigidBodyDynamics.jl/tree/6f579338a933afb6a32ed7c8113e92a8f4db5772/src/mechanism_algorithms.jl#L22">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.center_of_mass-Tuple{RigidBodyDynamics.MechanismState}" href="#RigidBodyDynamics.center_of_mass-Tuple{RigidBodyDynamics.MechanismState}"><code>RigidBodyDynamics.center_of_mass</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">center_of_mass(state)
</code></pre><p>Compute the center of mass of the whole <code>Mechanism</code> in the given state.</p></div><a class="source-link" target="_blank" href="https://github.com/tkoolen/RigidBodyDynamics.jl/tree/6f579338a933afb6a32ed7c8113e92a8f4db5772/src/mechanism_algorithms.jl#L48">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.dynamics!" href="#RigidBodyDynamics.dynamics!"><code>RigidBodyDynamics.dynamics!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-julia">dynamics!(ẋ, result, state, stateVec, torques)
dynamics!(ẋ, result, state, stateVec, torques, externalwrenches)
dynamics!(ẋ, result, state, stateVec)
</code></pre><p>Convenience function for use with standard ODE integrators that takes a <code>Vector</code> argument</p><div>\[x = \left(\begin{array}{c}
q\\
v
\end{array}\right)\]</div><p>and returns a <code>Vector</code> <span>$\dot{x}$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/tkoolen/RigidBodyDynamics.jl/tree/6f579338a933afb6a32ed7c8113e92a8f4db5772/src/mechanism_algorithms.jl#L756">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.dynamics!" href="#RigidBodyDynamics.dynamics!"><code>RigidBodyDynamics.dynamics!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-julia">dynamics!(result, state)
dynamics!(result, state, torques)
dynamics!(result, state, torques, externalwrenches)
</code></pre><p>Compute the joint acceleration vector <span>$\dot{v}$</span> and Lagrange multipliers <span>$\lambda$</span> that satisfy the joint-space equations of motion</p><div>\[M(q) \dot{v} + c(q, v, w_\text{ext}) = \tau - K(q)^{T} \lambda\]</div><p>and the constraint equations</p><div>\[K(q) \dot{v} = -k\]</div><p>given joint configuration vector <span>$q$</span>, joint velocity vector <span>$v$</span>, and (optionally) joint torques <span>$\tau$</span> and external wrenches <span>$w_\text{ext}$</span>.</p><p>The <code>externalwrenches</code> argument can be used to specify additional wrenches that act on the <code>Mechanism</code>&#39;s bodies.</p></div><a class="source-link" target="_blank" href="https://github.com/tkoolen/RigidBodyDynamics.jl/tree/6f579338a933afb6a32ed7c8113e92a8f4db5772/src/mechanism_algorithms.jl#L722">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.geometric_jacobian!-Tuple{RigidBodyDynamics.GeometricJacobian,RigidBodyDynamics.MechanismState,RigidBodyDynamics.Graphs.TreePath,Any}" href="#RigidBodyDynamics.geometric_jacobian!-Tuple{RigidBodyDynamics.GeometricJacobian,RigidBodyDynamics.MechanismState,RigidBodyDynamics.Graphs.TreePath,Any}"><code>RigidBodyDynamics.geometric_jacobian!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">geometric_jacobian!(out, state, path, transformfun)
</code></pre><p>Compute a geometric Jacobian (also known as a basic, or spatial Jacobian) associated with the joints that form a path in the <code>Mechanism</code>&#39;s spanning tree, in the given state.</p><p>A geometric Jacobian maps the vector of velocities associated with the joint path to the twist of the body succeeding the last joint in the path with respect to the body preceding the first joint in the path.</p><p>See also <a href="mechanism.html#RigidBodyDynamics.Graphs.path-Tuple{RigidBodyDynamics.Mechanism,RigidBodyDynamics.RigidBody,RigidBodyDynamics.RigidBody}"><code>path</code></a>, <a href="spatial.html#RigidBodyDynamics.GeometricJacobian"><code>GeometricJacobian</code></a>, <a href="mechanismstate.html#RigidBodyDynamics.velocity-Tuple{RigidBodyDynamics.MechanismState,RigidBodyDynamics.Joint}"><code>velocity(state, path)</code></a>, <a href="spatial.html#RigidBodyDynamics.Twist"><code>Twist</code></a>.</p><p><code>transformfun</code> is a callable that may be used to transform the individual motion subspaces of each of the joints to the frame in which <code>out</code> is expressed.</p><p>This method does its computation in place, performing no dynamic memory allocation.</p></div><a class="source-link" target="_blank" href="https://github.com/tkoolen/RigidBodyDynamics.jl/tree/6f579338a933afb6a32ed7c8113e92a8f4db5772/src/mechanism_algorithms.jl#L78-L89">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.geometric_jacobian!-Tuple{RigidBodyDynamics.GeometricJacobian,RigidBodyDynamics.MechanismState,RigidBodyDynamics.Graphs.TreePath,RigidBodyDynamics.Transform3D}" href="#RigidBodyDynamics.geometric_jacobian!-Tuple{RigidBodyDynamics.GeometricJacobian,RigidBodyDynamics.MechanismState,RigidBodyDynamics.Graphs.TreePath,RigidBodyDynamics.Transform3D}"><code>RigidBodyDynamics.geometric_jacobian!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">geometric_jacobian!(out, state, path, root_to_desired)
</code></pre><p>Compute a geometric Jacobian (also known as a basic, or spatial Jacobian) associated with the joints that form a path in the <code>Mechanism</code>&#39;s spanning tree, in the given state.</p><p>A geometric Jacobian maps the vector of velocities associated with the joint path to the twist of the body succeeding the last joint in the path with respect to the body preceding the first joint in the path.</p><p>See also <a href="mechanism.html#RigidBodyDynamics.Graphs.path-Tuple{RigidBodyDynamics.Mechanism,RigidBodyDynamics.RigidBody,RigidBodyDynamics.RigidBody}"><code>path</code></a>, <a href="spatial.html#RigidBodyDynamics.GeometricJacobian"><code>GeometricJacobian</code></a>, <a href="mechanismstate.html#RigidBodyDynamics.velocity-Tuple{RigidBodyDynamics.MechanismState,RigidBodyDynamics.Joint}"><code>velocity(state, path)</code></a>, <a href="spatial.html#RigidBodyDynamics.Twist"><code>Twist</code></a>.</p><p><code>root_to_desired</code> is the transform from the <code>Mechanism</code>&#39;s root frame to the frame in which <code>out</code> is expressed.</p><p>This method does its computation in place, performing no dynamic memory allocation.</p></div><a class="source-link" target="_blank" href="https://github.com/tkoolen/RigidBodyDynamics.jl/tree/6f579338a933afb6a32ed7c8113e92a8f4db5772/src/mechanism_algorithms.jl#L103-L114">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.geometric_jacobian!-Tuple{RigidBodyDynamics.GeometricJacobian,RigidBodyDynamics.MechanismState,RigidBodyDynamics.Graphs.TreePath}" href="#RigidBodyDynamics.geometric_jacobian!-Tuple{RigidBodyDynamics.GeometricJacobian,RigidBodyDynamics.MechanismState,RigidBodyDynamics.Graphs.TreePath}"><code>RigidBodyDynamics.geometric_jacobian!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">geometric_jacobian!(out, state, path)
</code></pre><p>Compute a geometric Jacobian (also known as a basic, or spatial Jacobian) associated with the joints that form a path in the <code>Mechanism</code>&#39;s spanning tree, in the given state.</p><p>A geometric Jacobian maps the vector of velocities associated with the joint path to the twist of the body succeeding the last joint in the path with respect to the body preceding the first joint in the path.</p><p>See also <a href="mechanism.html#RigidBodyDynamics.Graphs.path-Tuple{RigidBodyDynamics.Mechanism,RigidBodyDynamics.RigidBody,RigidBodyDynamics.RigidBody}"><code>path</code></a>, <a href="spatial.html#RigidBodyDynamics.GeometricJacobian"><code>GeometricJacobian</code></a>, <a href="mechanismstate.html#RigidBodyDynamics.velocity-Tuple{RigidBodyDynamics.MechanismState,RigidBodyDynamics.Joint}"><code>velocity(state, path)</code></a>, <a href="spatial.html#RigidBodyDynamics.Twist"><code>Twist</code></a>.</p><p>See <a href="algorithms.html#RigidBodyDynamics.geometric_jacobian!-Tuple{RigidBodyDynamics.GeometricJacobian,RigidBodyDynamics.MechanismState,RigidBodyDynamics.Graphs.TreePath,Any}"><code>geometric_jacobian!(out, state, path, root_to_desired)</code></a>. Uses <code>state</code> to compute the transform from the <code>Mechanism</code>&#39;s root frame to the frame in which <code>out</code> is expressed.</p><p>This method does its computation in place, performing no dynamic memory allocation.</p></div><a class="source-link" target="_blank" href="https://github.com/tkoolen/RigidBodyDynamics.jl/tree/6f579338a933afb6a32ed7c8113e92a8f4db5772/src/mechanism_algorithms.jl#L117-L128">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.geometric_jacobian-Tuple{RigidBodyDynamics.MechanismState{X,M,C},RigidBodyDynamics.Graphs.TreePath{RigidBodyDynamics.RigidBody{M},RigidBodyDynamics.Joint{M}}}" href="#RigidBodyDynamics.geometric_jacobian-Tuple{RigidBodyDynamics.MechanismState{X,M,C},RigidBodyDynamics.Graphs.TreePath{RigidBodyDynamics.RigidBody{M},RigidBodyDynamics.Joint{M}}}"><code>RigidBodyDynamics.geometric_jacobian</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">geometric_jacobian(state, path)
</code></pre><p>Compute a geometric Jacobian (also known as a basic, or spatial Jacobian) associated with the joints that form a path in the <code>Mechanism</code>&#39;s spanning tree, in the given state.</p><p>A geometric Jacobian maps the vector of velocities associated with the joint path to the twist of the body succeeding the last joint in the path with respect to the body preceding the first joint in the path.</p><p>See also <a href="mechanism.html#RigidBodyDynamics.Graphs.path-Tuple{RigidBodyDynamics.Mechanism,RigidBodyDynamics.RigidBody,RigidBodyDynamics.RigidBody}"><code>path</code></a>, <a href="spatial.html#RigidBodyDynamics.GeometricJacobian"><code>GeometricJacobian</code></a>, <a href="mechanismstate.html#RigidBodyDynamics.velocity-Tuple{RigidBodyDynamics.MechanismState,RigidBodyDynamics.Joint}"><code>velocity(state, path)</code></a>, <a href="spatial.html#RigidBodyDynamics.Twist"><code>Twist</code></a>.</p><p>The Jacobian is computed in the <code>Mechanism</code>&#39;s root frame.</p><p>See <a href="algorithms.html#RigidBodyDynamics.geometric_jacobian!-Tuple{RigidBodyDynamics.GeometricJacobian,RigidBodyDynamics.MechanismState,RigidBodyDynamics.Graphs.TreePath,Any}"><code>geometric_jacobian!(out, state, path)</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/tkoolen/RigidBodyDynamics.jl/tree/6f579338a933afb6a32ed7c8113e92a8f4db5772/src/mechanism_algorithms.jl#L136-L147">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.gravitational_potential_energy-Tuple{RigidBodyDynamics.MechanismState{X,M,C}}" href="#RigidBodyDynamics.gravitational_potential_energy-Tuple{RigidBodyDynamics.MechanismState{X,M,C}}"><code>RigidBodyDynamics.gravitational_potential_energy</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">gravitational_potential_energy(state)
</code></pre><p>Return the gravitational potential energy in the given state, computed as the negation of the dot product of the gravitational force and the center of mass expressed in the <code>Mechanism</code>&#39;s root frame.</p></div><a class="source-link" target="_blank" href="https://github.com/tkoolen/RigidBodyDynamics.jl/tree/6f579338a933afb6a32ed7c8113e92a8f4db5772/src/mechanism_algorithms.jl#L196">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.inverse_dynamics" href="#RigidBodyDynamics.inverse_dynamics"><code>RigidBodyDynamics.inverse_dynamics</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-julia">inverse_dynamics(state, v̇, externalwrenches)
inverse_dynamics(state, v̇)
</code></pre><p>Do inverse dynamics, i.e. compute <span>$\tau$</span> in the unconstrained joint-space equations of motion</p><div>\[M(q) \dot{v} + c(q, v, w_\text{ext}) = \tau\]</div><p>given joint configuration vector <span>$q$</span>, joint velocity vector <span>$v$</span>, joint acceleration vector <span>$\dot{v}$</span> and (optionally) external wrenches <span>$w_\text{ext}$</span>.</p><p>The <code>externalwrenches</code> argument can be used to specify additional wrenches that act on the <code>Mechanism</code>&#39;s bodies.</p><p>This method implements the recursive Newton-Euler algorithm.</p><p>Currently doesn&#39;t support <code>Mechanism</code>s with cycles.</p></div><a class="source-link" target="_blank" href="https://github.com/tkoolen/RigidBodyDynamics.jl/tree/6f579338a933afb6a32ed7c8113e92a8f4db5772/src/mechanism_algorithms.jl#L526-L542">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.inverse_dynamics!" href="#RigidBodyDynamics.inverse_dynamics!"><code>RigidBodyDynamics.inverse_dynamics!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-julia">inverse_dynamics!(torquesout, jointwrenchesout, accelerations, state, v̇)
inverse_dynamics!(torquesout, jointwrenchesout, accelerations, state, v̇, externalwrenches)
</code></pre><p>Do inverse dynamics, i.e. compute <span>$\tau$</span> in the unconstrained joint-space equations of motion</p><div>\[M(q) \dot{v} + c(q, v, w_\text{ext}) = \tau\]</div><p>given joint configuration vector <span>$q$</span>, joint velocity vector <span>$v$</span>, joint acceleration vector <span>$\dot{v}$</span> and (optionally) external wrenches <span>$w_\text{ext}$</span>.</p><p>The <code>externalwrenches</code> argument can be used to specify additional wrenches that act on the <code>Mechanism</code>&#39;s bodies.</p><p>This method implements the recursive Newton-Euler algorithm.</p><p>Currently doesn&#39;t support <code>Mechanism</code>s with cycles.</p><p>This method does its computation in place, performing no dynamic memory allocation.</p></div><a class="source-link" target="_blank" href="https://github.com/tkoolen/RigidBodyDynamics.jl/tree/6f579338a933afb6a32ed7c8113e92a8f4db5772/src/mechanism_algorithms.jl#L506-L522">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.mass-Tuple{RigidBodyDynamics.Mechanism}" href="#RigidBodyDynamics.mass-Tuple{RigidBodyDynamics.Mechanism}"><code>RigidBodyDynamics.mass</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">mass(m)
</code></pre><p>Return the total mass of the <code>Mechanism</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/tkoolen/RigidBodyDynamics.jl/tree/6f579338a933afb6a32ed7c8113e92a8f4db5772/src/mechanism_algorithms.jl#L15">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.mass_matrix!-Tuple{Symmetric{C,Array{C,2}},RigidBodyDynamics.MechanismState{X,M,C}}" href="#RigidBodyDynamics.mass_matrix!-Tuple{Symmetric{C,Array{C,2}},RigidBodyDynamics.MechanismState{X,M,C}}"><code>RigidBodyDynamics.mass_matrix!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">mass_matrix!(out, state)
</code></pre><p>Compute the joint-space mass matrix (also known as the inertia matrix) of the <code>Mechanism</code> in the given state, i.e., the matrix <span>$M(q)$</span> in the unconstrained joint-space equations of motion</p><div>\[M(q) \dot{v} + c(q, v, w_\text{ext}) = \tau\]</div><p>This method implements the composite rigid body algorithm.</p><p>This method does its computation in place, performing no dynamic memory allocation.</p><p>The <code>out</code> argument must be an <span>$n_v \times n_v$</span> lower triangular <code>Symmetric</code> matrix, where <span>$n_v$</span> is the dimension of the <code>Mechanism</code>&#39;s joint velocity vector <span>$v$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/tkoolen/RigidBodyDynamics.jl/tree/6f579338a933afb6a32ed7c8113e92a8f4db5772/src/mechanism_algorithms.jl#L244-L253">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.mass_matrix-Tuple{RigidBodyDynamics.MechanismState{X,M,C}}" href="#RigidBodyDynamics.mass_matrix-Tuple{RigidBodyDynamics.MechanismState{X,M,C}}"><code>RigidBodyDynamics.mass_matrix</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">mass_matrix(state)
</code></pre><p>Compute the joint-space mass matrix (also known as the inertia matrix) of the <code>Mechanism</code> in the given state, i.e., the matrix <span>$M(q)$</span> in the unconstrained joint-space equations of motion</p><div>\[M(q) \dot{v} + c(q, v, w_\text{ext}) = \tau\]</div><p>This method implements the composite rigid body algorithm.</p></div><a class="source-link" target="_blank" href="https://github.com/tkoolen/RigidBodyDynamics.jl/tree/6f579338a933afb6a32ed7c8113e92a8f4db5772/src/mechanism_algorithms.jl#L288-L297">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.momentum_matrix!-Tuple{RigidBodyDynamics.MomentumMatrix,RigidBodyDynamics.MechanismState,Any}" href="#RigidBodyDynamics.momentum_matrix!-Tuple{RigidBodyDynamics.MomentumMatrix,RigidBodyDynamics.MechanismState,Any}"><code>RigidBodyDynamics.momentum_matrix!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">momentum_matrix!(out, state, transformfun)
</code></pre><p>Compute the momentum matrix <span>$A(q)$</span> of the <code>Mechanism</code> in the given state.</p><p>The momentum matrix maps the <code>Mechanism</code>&#39;s joint velocity vector <span>$v$</span> to its total momentum.</p><p>See also <a href="spatial.html#RigidBodyDynamics.MomentumMatrix"><code>MomentumMatrix</code></a>.</p><p>The <code>out</code> argument must be a mutable <code>MomentumMatrix</code> with as many columns as the dimension of the <code>Mechanism</code>&#39;s joint velocity vector <span>$v$</span>.</p><p><code>transformfun</code> is a callable that may be used to transform the individual momentum matrix blocks associated with each of the joints to the frame in which <code>out</code> is expressed.</p><p>This method does its computation in place, performing no dynamic memory allocation.</p></div><a class="source-link" target="_blank" href="https://github.com/tkoolen/RigidBodyDynamics.jl/tree/6f579338a933afb6a32ed7c8113e92a8f4db5772/src/mechanism_algorithms.jl#L314-L325">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.momentum_matrix!-Tuple{RigidBodyDynamics.MomentumMatrix,RigidBodyDynamics.MechanismState,RigidBodyDynamics.Transform3D}" href="#RigidBodyDynamics.momentum_matrix!-Tuple{RigidBodyDynamics.MomentumMatrix,RigidBodyDynamics.MechanismState,RigidBodyDynamics.Transform3D}"><code>RigidBodyDynamics.momentum_matrix!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">momentum_matrix!(out, state, root_to_desired)
</code></pre><p>Compute the momentum matrix <span>$A(q)$</span> of the <code>Mechanism</code> in the given state.</p><p>The momentum matrix maps the <code>Mechanism</code>&#39;s joint velocity vector <span>$v$</span> to its total momentum.</p><p>See also <a href="spatial.html#RigidBodyDynamics.MomentumMatrix"><code>MomentumMatrix</code></a>.</p><p>The <code>out</code> argument must be a mutable <code>MomentumMatrix</code> with as many columns as the dimension of the <code>Mechanism</code>&#39;s joint velocity vector <span>$v$</span>.</p><p><code>root_to_desired</code> is the transform from the <code>Mechanism</code>&#39;s root frame to the frame in which <code>out</code> is expressed.</p><p>This method does its computation in place, performing no dynamic memory allocation.</p></div><a class="source-link" target="_blank" href="https://github.com/tkoolen/RigidBodyDynamics.jl/tree/6f579338a933afb6a32ed7c8113e92a8f4db5772/src/mechanism_algorithms.jl#L340-L351">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.momentum_matrix!-Tuple{RigidBodyDynamics.MomentumMatrix,RigidBodyDynamics.MechanismState}" href="#RigidBodyDynamics.momentum_matrix!-Tuple{RigidBodyDynamics.MomentumMatrix,RigidBodyDynamics.MechanismState}"><code>RigidBodyDynamics.momentum_matrix!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">momentum_matrix!(out, state)
</code></pre><p>Compute the momentum matrix <span>$A(q)$</span> of the <code>Mechanism</code> in the given state.</p><p>The momentum matrix maps the <code>Mechanism</code>&#39;s joint velocity vector <span>$v$</span> to its total momentum.</p><p>See also <a href="spatial.html#RigidBodyDynamics.MomentumMatrix"><code>MomentumMatrix</code></a>.</p><p>The <code>out</code> argument must be a mutable <code>MomentumMatrix</code> with as many columns as the dimension of the <code>Mechanism</code>&#39;s joint velocity vector <span>$v$</span>.</p><p>See <a href="algorithms.html#RigidBodyDynamics.momentum_matrix!-Tuple{RigidBodyDynamics.MomentumMatrix,RigidBodyDynamics.MechanismState,Any}"><code>momentum_matrix!(out, state, root_to_desired)</code></a>. Uses <code>state</code> to compute the transform from the <code>Mechanism</code>&#39;s root frame to the frame in which <code>out</code> is expressed.</p><p>This method does its computation in place, performing no dynamic memory allocation.</p></div><a class="source-link" target="_blank" href="https://github.com/tkoolen/RigidBodyDynamics.jl/tree/6f579338a933afb6a32ed7c8113e92a8f4db5772/src/mechanism_algorithms.jl#L354-L365">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.momentum_matrix-Tuple{RigidBodyDynamics.MechanismState}" href="#RigidBodyDynamics.momentum_matrix-Tuple{RigidBodyDynamics.MechanismState}"><code>RigidBodyDynamics.momentum_matrix</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">momentum_matrix(state)
</code></pre><p>Compute the momentum matrix <span>$A(q)$</span> of the <code>Mechanism</code> in the given state.</p><p>The momentum matrix maps the <code>Mechanism</code>&#39;s joint velocity vector <span>$v$</span> to its total momentum.</p><p>See also <a href="spatial.html#RigidBodyDynamics.MomentumMatrix"><code>MomentumMatrix</code></a>.</p><p>See <a href="algorithms.html#RigidBodyDynamics.momentum_matrix!-Tuple{RigidBodyDynamics.MomentumMatrix,RigidBodyDynamics.MechanismState,Any}"><code>momentum_matrix!(out, state)</code></a>.</p></div><a class="source-link" target="_blank" href="https://github.com/tkoolen/RigidBodyDynamics.jl/tree/6f579338a933afb6a32ed7c8113e92a8f4db5772/src/mechanism_algorithms.jl#L373-L381">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.relative_acceleration-Tuple{RigidBodyDynamics.MechanismState,RigidBodyDynamics.RigidBody,RigidBodyDynamics.RigidBody,AbstractArray{T,1}}" href="#RigidBodyDynamics.relative_acceleration-Tuple{RigidBodyDynamics.MechanismState,RigidBodyDynamics.RigidBody,RigidBodyDynamics.RigidBody,AbstractArray{T,1}}"><code>RigidBodyDynamics.relative_acceleration</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">relative_acceleration(state, body, base, v̇)
</code></pre><p>Compute the spatial acceleration of <code>body</code> with respect to <code>base</code> for the given state and joint acceleration vector <span>$\dot{v}$</span>.</p></div><a class="source-link" target="_blank" href="https://github.com/tkoolen/RigidBodyDynamics.jl/tree/6f579338a933afb6a32ed7c8113e92a8f4db5772/src/mechanism_algorithms.jl#L155">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.dynamics_bias!" href="#RigidBodyDynamics.dynamics_bias!"><code>RigidBodyDynamics.dynamics_bias!</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-julia">dynamics_bias!(torques, biasaccelerations, wrenches, state, externalwrenches)
dynamics_bias!(torques, biasaccelerations, wrenches, state)
</code></pre><p>Compute the &#39;dynamics bias term&#39;, i.e. the term</p><div>\[c(q, v, w_\text{ext})\]</div><p>in the unconstrained joint-space equations of motion</p><div>\[M(q) \dot{v} + c(q, v, w_\text{ext}) = \tau\]</div><p>given joint configuration vector <span>$q$</span>, joint velocity vector <span>$v$</span>, joint acceleration vector <span>$\dot{v}$</span> and (optionally) external wrenches <span>$w_\text{ext}$</span>.</p><p>The <code>externalwrenches</code> argument can be used to specify additional wrenches that act on the <code>Mechanism</code>&#39;s bodies.</p><p>This method does its computation in place, performing no dynamic memory allocation.</p></div><a class="source-link" target="_blank" href="https://github.com/tkoolen/RigidBodyDynamics.jl/tree/6f579338a933afb6a32ed7c8113e92a8f4db5772/src/mechanism_algorithms.jl#L458">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="RigidBodyDynamics.subtree_mass-Tuple{RigidBodyDynamics.RigidBody{T},RigidBodyDynamics.Mechanism{T}}" href="#RigidBodyDynamics.subtree_mass-Tuple{RigidBodyDynamics.RigidBody{T},RigidBodyDynamics.Mechanism{T}}"><code>RigidBodyDynamics.subtree_mass</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">subtree_mass(base, mechanism)
</code></pre><p>Return the mass of a subtree of a <code>Mechanism</code>, rooted at <code>base</code> (including the mass of <code>base</code>).</p></div><a class="source-link" target="_blank" href="https://github.com/tkoolen/RigidBodyDynamics.jl/tree/6f579338a933afb6a32ed7c8113e92a8f4db5772/src/mechanism_algorithms.jl#L1">source</a><br/></section><footer><hr/><a class="previous" href="mechanismstate.html"><span class="direction">Previous</span><span class="title">MechanismState</span></a><a class="next" href="simulation.html"><span class="direction">Next</span><span class="title">Simulation</span></a></footer></article></body></html>
