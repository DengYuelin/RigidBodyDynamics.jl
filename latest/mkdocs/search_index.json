{
    "docs": [
        {
            "location": "/", 
            "text": "RigidBodyDynamics\n\n\nRigidBodyDynamics implements various rigid body dynamics and kinematics algorithms.\n\n\n\n\nDesign features\n\n\nSome of the key design features of this package are:\n\n\n\n\npure Julia implementation, enabling seamless support for e.g. automatic differentiation using \nForwardDiff.jl\n and symbolic dynamics using \nSymPy.jl\n.\n\n\neasy creation and modification of general rigid body mechanisms (including basic \nURDF\n parsing).\n\n\nextensive checks that verify that coordinate systems match before computation, with the goal of making reference frame mistakes impossible\n\n\nflexible caching of intermediate results to prevent doing double work\n\n\nfairly small codebase and few dependencies\n\n\nsingularity-free rotation parameterizations\n\n\n\n\n\n\nFunctionality\n\n\nCurrent functionality of RigidBodyDynamics includes:\n\n\n\n\nkinematics/transforming points and free vectors from one coordinate system to another\n\n\ntransforming wrenches, momenta (spatial force vectors) and twists and their derivatives (spatial motion vectors) from one coordinate system to another\n\n\nrelative twists/spatial accelerations between bodies\n\n\nkinetic/potential energy\n\n\ncenter of mass\n\n\ngeometric/basic/spatial Jacobians\n\n\nmomentum\n\n\nmomentum matrix\n\n\nmomentum rate bias (= momentum matrix time derivative multiplied by joint velocity vector)\n\n\nmass matrix (composite rigid body algorithm)\n\n\ninverse dynamics (recursive Newton-Euler)\n\n\ndynamics\n\n\nsimulation, either using an off-the-shelf ODE integrator or using an included custom Munthe-Kaas integrator that properly handles second-order ODEs defined on a manifold.\n\n\n\n\nThere is currently partial support for closed-loop systems (parallel mechanisms); more features will be added soon in this area. Contact is not yet supported.\n\n\n\n\nInstallation\n\n\n\n\nInstalling Julia\n\n\nDownload links and more detailed instructions are available on the \nJulia\n website.\n\n\n\n\nInstalling RigidBodyDynamics\n\n\nTo install the latest tagged release of RigidBodyDynamics, simply run\n\n\nPkg.add(\nRigidBodyDynamics\n)\u00a0\n\n\n\n\nTo check out the master branch and work on the bleeding edge, additionally run\n\n\nPkg.checkout(\nRigidBodyDynamics\n)\n\n\n\n\nRigidBodyDynamics currently only supports version 0.5 of Julia.\n\n\n\n\nAbout\n\n\nThis library was inspired by \nIHMCRoboticsToolkit\n and by \nDrake\n.\n\n\nMost of the nomenclature used and algorithms implemented by this package stem from the following resources:\n\n\n\n\nMurray, Richard M., et al. \nA mathematical introduction to robotic manipulation\n. CRC press, 1994.\n\n\nFeatherstone, Roy. \nRigid body dynamics algorithms\n. Springer, 2008.\n\n\nDuindam, Vincent. \nPort-based modeling and control for efficient bipedal walking robots\n. Diss. University of Twente, 2006.\n\n\n\n\n\n\nRelated packages\n\n\n\n\nRigidBodyTreeInspector.jl\n - 3D visualization of RigidBodyDynamics.jl \nMechanism\ns using \nDirector\n.\n\n\n\n\n\n\nContents\n\n\n\n\nQuick start guide\n\n\nSpatial vector algebra\n\n\nIndex\n\n\nTypes\n\n\nThe \n@framecheck\n macro\n\n\nFunctions\n\n\n\n\n\n\nJoints\n\n\nIndex\n\n\nThe \nJoint\n type\n\n\nFunctions\n\n\nJointType\ns\n\n\n\n\n\n\nRigid bodies\n\n\nIndex\n\n\nThe \nRigidBody\n type\n\n\nFunctions\n\n\n\n\n\n\nMechanisms\n\n\nIndex\n\n\nThe \nMechanism\n type\n\n\nBasic functionality\n\n\nCreating and modifying \nMechanism\ns\n\n\n\n\n\n\nMechanismState\n\n\nIndex\n\n\nThe \nMechanismState\n type\n\n\nFunctions\n\n\n\n\n\n\nAlgorithms\n\n\nIndex\n\n\nThe \nDynamicsResult\n type\n\n\nFunctions\n\n\n\n\n\n\nSimulation\n\n\nIndex\n\n\nBasic simulation\n\n\nLower level ODE integration interface\n\n\n\n\n\n\nBenchmarks\n\n\n\n\n\n\nCiting this library\n\n\n@misc{rigidbodydynamicsjl,\n author = \nTwan Koolen and contributors\n,\n title = \nRigidBodyDynamics.jl\n,\n year = 2016,\n url = \nhttps://github.com/tkoolen/RigidBodyDynamics.jl\n\n}", 
            "title": "Home"
        }, 
        {
            "location": "/#rigidbodydynamics", 
            "text": "RigidBodyDynamics implements various rigid body dynamics and kinematics algorithms.", 
            "title": "RigidBodyDynamics"
        }, 
        {
            "location": "/#design-features", 
            "text": "Some of the key design features of this package are:   pure Julia implementation, enabling seamless support for e.g. automatic differentiation using  ForwardDiff.jl  and symbolic dynamics using  SymPy.jl .  easy creation and modification of general rigid body mechanisms (including basic  URDF  parsing).  extensive checks that verify that coordinate systems match before computation, with the goal of making reference frame mistakes impossible  flexible caching of intermediate results to prevent doing double work  fairly small codebase and few dependencies  singularity-free rotation parameterizations", 
            "title": "Design features"
        }, 
        {
            "location": "/#functionality", 
            "text": "Current functionality of RigidBodyDynamics includes:   kinematics/transforming points and free vectors from one coordinate system to another  transforming wrenches, momenta (spatial force vectors) and twists and their derivatives (spatial motion vectors) from one coordinate system to another  relative twists/spatial accelerations between bodies  kinetic/potential energy  center of mass  geometric/basic/spatial Jacobians  momentum  momentum matrix  momentum rate bias (= momentum matrix time derivative multiplied by joint velocity vector)  mass matrix (composite rigid body algorithm)  inverse dynamics (recursive Newton-Euler)  dynamics  simulation, either using an off-the-shelf ODE integrator or using an included custom Munthe-Kaas integrator that properly handles second-order ODEs defined on a manifold.   There is currently partial support for closed-loop systems (parallel mechanisms); more features will be added soon in this area. Contact is not yet supported.", 
            "title": "Functionality"
        }, 
        {
            "location": "/#installation", 
            "text": "", 
            "title": "Installation"
        }, 
        {
            "location": "/#installing-julia", 
            "text": "Download links and more detailed instructions are available on the  Julia  website.", 
            "title": "Installing Julia"
        }, 
        {
            "location": "/#installing-rigidbodydynamics", 
            "text": "To install the latest tagged release of RigidBodyDynamics, simply run  Pkg.add( RigidBodyDynamics )\u00a0  To check out the master branch and work on the bleeding edge, additionally run  Pkg.checkout( RigidBodyDynamics )  RigidBodyDynamics currently only supports version 0.5 of Julia.", 
            "title": "Installing RigidBodyDynamics"
        }, 
        {
            "location": "/#about", 
            "text": "This library was inspired by  IHMCRoboticsToolkit  and by  Drake .  Most of the nomenclature used and algorithms implemented by this package stem from the following resources:   Murray, Richard M., et al.  A mathematical introduction to robotic manipulation . CRC press, 1994.  Featherstone, Roy.  Rigid body dynamics algorithms . Springer, 2008.  Duindam, Vincent.  Port-based modeling and control for efficient bipedal walking robots . Diss. University of Twente, 2006.", 
            "title": "About"
        }, 
        {
            "location": "/#related-packages", 
            "text": "RigidBodyTreeInspector.jl  - 3D visualization of RigidBodyDynamics.jl  Mechanism s using  Director .", 
            "title": "Related packages"
        }, 
        {
            "location": "/#contents", 
            "text": "Quick start guide  Spatial vector algebra  Index  Types  The  @framecheck  macro  Functions    Joints  Index  The  Joint  type  Functions  JointType s    Rigid bodies  Index  The  RigidBody  type  Functions    Mechanisms  Index  The  Mechanism  type  Basic functionality  Creating and modifying  Mechanism s    MechanismState  Index  The  MechanismState  type  Functions    Algorithms  Index  The  DynamicsResult  type  Functions    Simulation  Index  Basic simulation  Lower level ODE integration interface    Benchmarks", 
            "title": "Contents"
        }, 
        {
            "location": "/#citing-this-library", 
            "text": "@misc{rigidbodydynamicsjl,\n author =  Twan Koolen and contributors ,\n title =  RigidBodyDynamics.jl ,\n year = 2016,\n url =  https://github.com/tkoolen/RigidBodyDynamics.jl \n}", 
            "title": "Citing this library"
        }, 
        {
            "location": "/quickstart/", 
            "text": "Quick start guide\n\n\nTo get started, see \nthis Jupyter notebook\n.\n\n\nIf you're interested in using different scalar types, see the \nsymbolic double pendulum\n notebook.", 
            "title": "Quick start guide"
        }, 
        {
            "location": "/quickstart/#quick-start-guide", 
            "text": "To get started, see  this Jupyter notebook .  If you're interested in using different scalar types, see the  symbolic double pendulum  notebook.", 
            "title": "Quick start guide"
        }, 
        {
            "location": "/spatial/", 
            "text": "Spatial vector algebra\n\n\n\n\nIndex\n\n\n\n\nRigidBodyDynamics.CartesianFrame3D\n\n\nRigidBodyDynamics.FreeVector3D\n\n\nRigidBodyDynamics.GeometricJacobian\n\n\nRigidBodyDynamics.Momentum\n\n\nRigidBodyDynamics.MomentumMatrix\n\n\nRigidBodyDynamics.Point3D\n\n\nRigidBodyDynamics.SpatialAcceleration\n\n\nRigidBodyDynamics.SpatialInertia\n\n\nRigidBodyDynamics.Transform3D\n\n\nRigidBodyDynamics.Twist\n\n\nRigidBodyDynamics.Wrench\n\n\nBase.LinAlg.dot\n\n\nBase.exp\n\n\nBase.log\n\n\nRigidBodyDynamics.center_of_mass\n\n\nRigidBodyDynamics.kinetic_energy\n\n\nRigidBodyDynamics.log_with_time_derivative\n\n\nRigidBodyDynamics.newton_euler\n\n\nRigidBodyDynamics.num_cols\n\n\nRigidBodyDynamics.transform\n\n\nRigidBodyDynamics.transform\n\n\nRigidBodyDynamics.transform\n\n\nRigidBodyDynamics.transform\n\n\nRigidBodyDynamics.@framecheck\n\n\n\n\n\n\nTypes\n\n\n\n\nCoordinate frames\n\n\n#\n\n\nRigidBodyDynamics.CartesianFrame3D\n \n \nType\n.\n\n\nbitstype 64 CartesianFrame3D\n\n\n\n\nA \nCartesianFrame3D\n identifies a three-dimensional Cartesian coordinate system.\n\n\nCartesianFrame3D\ns are typically used to annotate the frame in which certain quantities are expressed.\n\n\nsource\n\n\n\n\nTransforms\n\n\n#\n\n\nRigidBodyDynamics.Transform3D\n \n \nType\n.\n\n\nimmutable Transform3D{T\n:Number}\n\n\n\n\nA homogeneous transformation matrix representing the transformation from one three-dimensional Cartesian coordinate system to another.\n\n\nsource\n\n\n\n\nPoints, free vectors\n\n\n#\n\n\nRigidBodyDynamics.Point3D\n \n \nType\n.\n\n\ntype Point3D{V\n:AbstractArray{T,1}}\n\n\n\n\nA \nPoint3D\n represents a position in a given coordinate system.\n\n\nA \nPoint3D\n is a \nbound vector\n. Applying a \nTransform3D\n to a \nPoint3D\n both rotates and translates the \nPoint3D\n.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.FreeVector3D\n \n \nType\n.\n\n\ntype FreeVector3D{V\n:AbstractArray{T,1}}\n\n\n\n\nA \nFreeVector3D\n represents a \nfree vector\n.\n\n\nExamples of free vectors include displacements and velocities of points.\n\n\nApplying a \nTransform3D\n to a \nFreeVector3D\n only rotates the \nFreeVector3D\n.\n\n\nsource\n\n\n\n\nInertias\n\n\n#\n\n\nRigidBodyDynamics.SpatialInertia\n \n \nType\n.\n\n\nimmutable SpatialInertia{T\n:Number}\n\n\n\n\nA spatial inertia, or inertia matrix, represents the mass distribution of a rigid body.\n\n\nA spatial inertia expressed in frame $i$ is defined as:\n\n\n\n\n\nI^i =\n\\int_{B}\\rho\\left(x\\right)\\left[\\begin{array}{cc}\n\\hat{p}^{T}\\left(x\\right)\\hat{p}\\left(x\\right) & \\hat{p}\\left(x\\right)\\\\\n\\hat{p}^{T}\\left(x\\right) & I\n\\end{array}\\right]dx=\\left[\\begin{array}{cc}\nJ & \\hat{c}\\\\\n\\hat{c}^{T} & mI\n\\end{array}\\right]\n\n\n\n\n\nwhere $\\rho(x)$ is the density of point $x$, and $p(x)$ are the coordinates of point $x$ expressed in frame $i$. $J$ is the mass moment of inertia, $m$ is the total mass, and $c$ is the 'cross part', center of mass position scaled by $m$.\n\n\nsource\n\n\n\n\nTwists, spatial accelerations\n\n\n#\n\n\nRigidBodyDynamics.Twist\n \n \nType\n.\n\n\nimmutable Twist{T\n:Number}\n\n\n\n\nA twist represents the relative angular and linear motion between two bodies.\n\n\nThe twist of frame $j$ with respect to frame $i$, expressed in frame $k$ is defined as\n\n\n\n\n\nT_{j}^{k,i}=\\left(\\begin{array}{c}\n\\omega_{j}^{k,i}\\\\\nv_{j}^{k,i}\n\\end{array}\\right)\\in\\mathbb{R}^{6}\n\n\n\n\n\nsuch that\n\n\n\n\n\n\\hat{T}_{j}^{k,i}=\\left[\\begin{array}{cc}\n\\hat{\\omega}_{j}^{k,i} & v_{j}^{k,i}\\\\\n0 & 0\n\\end{array}\\right]=H_{i}^{k}\\dot{H}_{j}^{i}H_{k}^{j}\n\n\n\n\n\nwhere $H^{\\beta}_{\\alpha}$ is the homogeneous transform from frame $\\alpha$ to frame $\\beta$, and $\\hat{x}$ is the $3 \\times 3$ skew symmetric matrix that satisfies $\\hat{x} y = x \\times y$ for all $y \\in \\mathbb{R}^3$.\n\n\nHere, $\\omega_{j}^{k,i}$ is the angular part and $v_{j}^{k,i}$ is the linear part. Note that the linear part is not in general the same as the linear velocity of the origin of frame $j$.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.SpatialAcceleration\n \n \nType\n.\n\n\nimmutable SpatialAcceleration{T\n:Number}\n\n\n\n\nA spatial acceleration is the time derivative of a twist.\n\n\nSee \nTwist\n.\n\n\nsource\n\n\n\n\nMomenta, wrenches\n\n\n#\n\n\nRigidBodyDynamics.Momentum\n \n \nType\n.\n\n\nimmutable Momentum{T\n:Number}\n\n\n\n\nA \nMomentum\n is the product of a \nSpatialInertia\n and a \nTwist\n, i.e.\n\n\n\n\n\nh^i =\n\\left(\\begin{array}{c}\nk^{i}\\\\\nl^{i}\n\\end{array}\\right) =\nI^i T^{i, j}_k\n\n\n\n\n\nwhere $I^i$ is the spatial inertia of a given body expressed in frame $i$, and $T^{i, j}_k$ is the twist of frame $k$ (attached to the body) with respect to inertial frame $j$, expressed in frame $i$. $k^i$ is the angular momentum and $l^i$ is the linear momentum.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.Wrench\n \n \nType\n.\n\n\nimmutable Wrench{T\n:Number}\n\n\n\n\nA wrench represents a system of forces.\n\n\nThe wrench $w^i$ expressed in frame $i$ is defined as\n\n\n\n\n\nw^{i} =\n\\left(\\begin{array}{c}\n\\tau^{i}\\\\\nf^{i}\n\\end{array}\\right) =\n\\sum_{j}\\left(\\begin{array}{c}\nr_{j}^{i}\\times f_{j}^{i}\\\\\nf_{j}^{i}\n\\end{array}\\right)\n\n\n\n\n\nwhere the $f_{j}^{i}$ are forces expressed in frame $i$, exerted at positions $r_{j}^{i}$. $\\tau^i$ is the total torque and $f^i$ is the total force.\n\n\nsource\n\n\n\n\nGeometric Jacobians\n\n\n#\n\n\nRigidBodyDynamics.GeometricJacobian\n \n \nType\n.\n\n\nimmutable GeometricJacobian{A\n:AbstractArray{T,2}}\n\n\n\n\nA geometric Jacobian (also known as basic, or spatial Jacobian) maps a vector of joint velocities to a twist.\n\n\nsource\n\n\n\n\nMomentum matrices\n\n\n#\n\n\nRigidBodyDynamics.MomentumMatrix\n \n \nType\n.\n\n\nimmutable MomentumMatrix{A\n:AbstractArray{T,2}}\n\n\n\n\nA momentum matrix maps a joint velocity vector to momentum.\n\n\nThis is a slight generalization of the centroidal momentum matrix (Orin, Goswami, \"Centroidal momentum matrix of a humanoid robot: Structure and properties.\") in that the matrix (and hence the corresponding total momentum) need not be expressed in a centroidal frame.\n\n\nsource\n\n\n\n\nThe \n@framecheck\n macro\n\n\n#\n\n\nRigidBodyDynamics.@framecheck\n \n \nMacro\n.\n\n\n@framecheck(f1, f2)\n\n\n\n\n\nCheck that \nf1\n and \nf2\n are identical (when bounds checks are enabled).\n\n\nThrows an \nArgumentError\n if \nf1\n is not identical to \nf2\n when bounds checks are enabled. \n@framecheck\n is a no-op when bounds checks are disabled.\n\n\nsource\n\n\n\n\nFunctions\n\n\n#\n\n\nRigidBodyDynamics.center_of_mass\n \n \nMethod\n.\n\n\ncenter_of_mass(inertia)\n\n\n\n\n\nReturn the center of mass of the \nSpatialInertia\n as a \nPoint3D\n.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.kinetic_energy\n \n \nMethod\n.\n\n\nkinetic_energy(I, twist)\n\n\n\n\n\nCompute the kinetic energy of a body with spatial inertia $I$, which has twist $T$ with respect to an inertial frame.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.newton_euler\n \n \nMethod\n.\n\n\nnewton_euler(I, \u1e6a, T)\n\n\n\n\n\nApply the Newton-Euler equations to find the external wrench required to make a body with spatial inertia $I$, which has twist $T$ with respect to an inertial frame, achieve spatial acceleration $\\dot{T}$.\n\n\nThis wrench is also equal to the rate of change of momentum of the body.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.num_cols\n \n \nMethod\n.\n\n\nnum_cols(jac)\n\n\n\n\n\nReturn the number of columns of the \nGeometricJacobian\n.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.transform\n \n \nMethod\n.\n\n\ntransform(jac, transform)\n\n\n\n\n\nTransform the \nGeometricJacobian\n to a different frame.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.transform\n \n \nMethod\n.\n\n\ntransform(accel, oldToNew, twistOfCurrentWrtNew, twistOfBodyWrtBase)\n\n\n\n\n\nTransform the \nSpatialAcceleration\n to a different frame.\n\n\nThe transformation rule is obtained by differentiating the transformation rule for twists.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.transform\n \n \nMethod\n.\n\n\ntransform(inertia, t)\n\n\n\n\n\nTransform the \nSpatialInertia\n to a different frame.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.transform\n \n \nMethod\n.\n\n\ntransform(twist, transform)\n\n\n\n\n\nTransform the \nTwist\n to a different frame.\n\n\nsource\n\n\n#\n\n\nBase.LinAlg.dot\n \n \nMethod\n.\n\n\ndot(w, t)\n\n\n\n\n\nCompute the mechanical power associated with a pairing of a wrench and a twist.\n\n\nsource\n\n\n#\n\n\nBase.exp\n \n \nMethod\n.\n\n\nexp(twist)\n\n\n\n\n\nConvert exponential coordinates to a homogeneous transform.\n\n\nsource\n\n\n#\n\n\nBase.log\n \n \nMethod\n.\n\n\nlog(t)\n\n\n\n\n\nExpress a homogeneous transform in exponential coordinates centered around the identity.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.log_with_time_derivative\n \n \nMethod\n.\n\n\nlog_with_time_derivative(t, twist)\n\n\n\n\n\nCompute exponential coordinates as well as their time derivatives in one shot. This mainly exists because ForwardDiff won't work at the singularity of \nlog\n. It is also ~50% faster than ForwardDiff in this case.\n\n\nsource", 
            "title": "Spatial vector algebra"
        }, 
        {
            "location": "/spatial/#spatial-vector-algebra", 
            "text": "", 
            "title": "Spatial vector algebra"
        }, 
        {
            "location": "/spatial/#index", 
            "text": "RigidBodyDynamics.CartesianFrame3D  RigidBodyDynamics.FreeVector3D  RigidBodyDynamics.GeometricJacobian  RigidBodyDynamics.Momentum  RigidBodyDynamics.MomentumMatrix  RigidBodyDynamics.Point3D  RigidBodyDynamics.SpatialAcceleration  RigidBodyDynamics.SpatialInertia  RigidBodyDynamics.Transform3D  RigidBodyDynamics.Twist  RigidBodyDynamics.Wrench  Base.LinAlg.dot  Base.exp  Base.log  RigidBodyDynamics.center_of_mass  RigidBodyDynamics.kinetic_energy  RigidBodyDynamics.log_with_time_derivative  RigidBodyDynamics.newton_euler  RigidBodyDynamics.num_cols  RigidBodyDynamics.transform  RigidBodyDynamics.transform  RigidBodyDynamics.transform  RigidBodyDynamics.transform  RigidBodyDynamics.@framecheck", 
            "title": "Index"
        }, 
        {
            "location": "/spatial/#types", 
            "text": "", 
            "title": "Types"
        }, 
        {
            "location": "/spatial/#coordinate-frames", 
            "text": "#  RigidBodyDynamics.CartesianFrame3D     Type .  bitstype 64 CartesianFrame3D  A  CartesianFrame3D  identifies a three-dimensional Cartesian coordinate system.  CartesianFrame3D s are typically used to annotate the frame in which certain quantities are expressed.  source", 
            "title": "Coordinate frames"
        }, 
        {
            "location": "/spatial/#transforms", 
            "text": "#  RigidBodyDynamics.Transform3D     Type .  immutable Transform3D{T :Number}  A homogeneous transformation matrix representing the transformation from one three-dimensional Cartesian coordinate system to another.  source", 
            "title": "Transforms"
        }, 
        {
            "location": "/spatial/#points-free-vectors", 
            "text": "#  RigidBodyDynamics.Point3D     Type .  type Point3D{V :AbstractArray{T,1}}  A  Point3D  represents a position in a given coordinate system.  A  Point3D  is a  bound vector . Applying a  Transform3D  to a  Point3D  both rotates and translates the  Point3D .  source  #  RigidBodyDynamics.FreeVector3D     Type .  type FreeVector3D{V :AbstractArray{T,1}}  A  FreeVector3D  represents a  free vector .  Examples of free vectors include displacements and velocities of points.  Applying a  Transform3D  to a  FreeVector3D  only rotates the  FreeVector3D .  source", 
            "title": "Points, free vectors"
        }, 
        {
            "location": "/spatial/#inertias", 
            "text": "#  RigidBodyDynamics.SpatialInertia     Type .  immutable SpatialInertia{T :Number}  A spatial inertia, or inertia matrix, represents the mass distribution of a rigid body.  A spatial inertia expressed in frame $i$ is defined as:   \nI^i =\n\\int_{B}\\rho\\left(x\\right)\\left[\\begin{array}{cc}\n\\hat{p}^{T}\\left(x\\right)\\hat{p}\\left(x\\right) & \\hat{p}\\left(x\\right)\\\\\n\\hat{p}^{T}\\left(x\\right) & I\n\\end{array}\\right]dx=\\left[\\begin{array}{cc}\nJ & \\hat{c}\\\\\n\\hat{c}^{T} & mI\n\\end{array}\\right]   where $\\rho(x)$ is the density of point $x$, and $p(x)$ are the coordinates of point $x$ expressed in frame $i$. $J$ is the mass moment of inertia, $m$ is the total mass, and $c$ is the 'cross part', center of mass position scaled by $m$.  source", 
            "title": "Inertias"
        }, 
        {
            "location": "/spatial/#twists-spatial-accelerations", 
            "text": "#  RigidBodyDynamics.Twist     Type .  immutable Twist{T :Number}  A twist represents the relative angular and linear motion between two bodies.  The twist of frame $j$ with respect to frame $i$, expressed in frame $k$ is defined as   \nT_{j}^{k,i}=\\left(\\begin{array}{c}\n\\omega_{j}^{k,i}\\\\\nv_{j}^{k,i}\n\\end{array}\\right)\\in\\mathbb{R}^{6}   such that   \n\\hat{T}_{j}^{k,i}=\\left[\\begin{array}{cc}\n\\hat{\\omega}_{j}^{k,i} & v_{j}^{k,i}\\\\\n0 & 0\n\\end{array}\\right]=H_{i}^{k}\\dot{H}_{j}^{i}H_{k}^{j}   where $H^{\\beta}_{\\alpha}$ is the homogeneous transform from frame $\\alpha$ to frame $\\beta$, and $\\hat{x}$ is the $3 \\times 3$ skew symmetric matrix that satisfies $\\hat{x} y = x \\times y$ for all $y \\in \\mathbb{R}^3$.  Here, $\\omega_{j}^{k,i}$ is the angular part and $v_{j}^{k,i}$ is the linear part. Note that the linear part is not in general the same as the linear velocity of the origin of frame $j$.  source  #  RigidBodyDynamics.SpatialAcceleration     Type .  immutable SpatialAcceleration{T :Number}  A spatial acceleration is the time derivative of a twist.  See  Twist .  source", 
            "title": "Twists, spatial accelerations"
        }, 
        {
            "location": "/spatial/#momenta-wrenches", 
            "text": "#  RigidBodyDynamics.Momentum     Type .  immutable Momentum{T :Number}  A  Momentum  is the product of a  SpatialInertia  and a  Twist , i.e.   \nh^i =\n\\left(\\begin{array}{c}\nk^{i}\\\\\nl^{i}\n\\end{array}\\right) =\nI^i T^{i, j}_k   where $I^i$ is the spatial inertia of a given body expressed in frame $i$, and $T^{i, j}_k$ is the twist of frame $k$ (attached to the body) with respect to inertial frame $j$, expressed in frame $i$. $k^i$ is the angular momentum and $l^i$ is the linear momentum.  source  #  RigidBodyDynamics.Wrench     Type .  immutable Wrench{T :Number}  A wrench represents a system of forces.  The wrench $w^i$ expressed in frame $i$ is defined as   \nw^{i} =\n\\left(\\begin{array}{c}\n\\tau^{i}\\\\\nf^{i}\n\\end{array}\\right) =\n\\sum_{j}\\left(\\begin{array}{c}\nr_{j}^{i}\\times f_{j}^{i}\\\\\nf_{j}^{i}\n\\end{array}\\right)   where the $f_{j}^{i}$ are forces expressed in frame $i$, exerted at positions $r_{j}^{i}$. $\\tau^i$ is the total torque and $f^i$ is the total force.  source", 
            "title": "Momenta, wrenches"
        }, 
        {
            "location": "/spatial/#geometric-jacobians", 
            "text": "#  RigidBodyDynamics.GeometricJacobian     Type .  immutable GeometricJacobian{A :AbstractArray{T,2}}  A geometric Jacobian (also known as basic, or spatial Jacobian) maps a vector of joint velocities to a twist.  source", 
            "title": "Geometric Jacobians"
        }, 
        {
            "location": "/spatial/#momentum-matrices", 
            "text": "#  RigidBodyDynamics.MomentumMatrix     Type .  immutable MomentumMatrix{A :AbstractArray{T,2}}  A momentum matrix maps a joint velocity vector to momentum.  This is a slight generalization of the centroidal momentum matrix (Orin, Goswami, \"Centroidal momentum matrix of a humanoid robot: Structure and properties.\") in that the matrix (and hence the corresponding total momentum) need not be expressed in a centroidal frame.  source", 
            "title": "Momentum matrices"
        }, 
        {
            "location": "/spatial/#the-framecheck-macro", 
            "text": "#  RigidBodyDynamics.@framecheck     Macro .  @framecheck(f1, f2)  Check that  f1  and  f2  are identical (when bounds checks are enabled).  Throws an  ArgumentError  if  f1  is not identical to  f2  when bounds checks are enabled.  @framecheck  is a no-op when bounds checks are disabled.  source", 
            "title": "The @framecheck macro"
        }, 
        {
            "location": "/spatial/#functions", 
            "text": "#  RigidBodyDynamics.center_of_mass     Method .  center_of_mass(inertia)  Return the center of mass of the  SpatialInertia  as a  Point3D .  source  #  RigidBodyDynamics.kinetic_energy     Method .  kinetic_energy(I, twist)  Compute the kinetic energy of a body with spatial inertia $I$, which has twist $T$ with respect to an inertial frame.  source  #  RigidBodyDynamics.newton_euler     Method .  newton_euler(I, \u1e6a, T)  Apply the Newton-Euler equations to find the external wrench required to make a body with spatial inertia $I$, which has twist $T$ with respect to an inertial frame, achieve spatial acceleration $\\dot{T}$.  This wrench is also equal to the rate of change of momentum of the body.  source  #  RigidBodyDynamics.num_cols     Method .  num_cols(jac)  Return the number of columns of the  GeometricJacobian .  source  #  RigidBodyDynamics.transform     Method .  transform(jac, transform)  Transform the  GeometricJacobian  to a different frame.  source  #  RigidBodyDynamics.transform     Method .  transform(accel, oldToNew, twistOfCurrentWrtNew, twistOfBodyWrtBase)  Transform the  SpatialAcceleration  to a different frame.  The transformation rule is obtained by differentiating the transformation rule for twists.  source  #  RigidBodyDynamics.transform     Method .  transform(inertia, t)  Transform the  SpatialInertia  to a different frame.  source  #  RigidBodyDynamics.transform     Method .  transform(twist, transform)  Transform the  Twist  to a different frame.  source  #  Base.LinAlg.dot     Method .  dot(w, t)  Compute the mechanical power associated with a pairing of a wrench and a twist.  source  #  Base.exp     Method .  exp(twist)  Convert exponential coordinates to a homogeneous transform.  source  #  Base.log     Method .  log(t)  Express a homogeneous transform in exponential coordinates centered around the identity.  source  #  RigidBodyDynamics.log_with_time_derivative     Method .  log_with_time_derivative(t, twist)  Compute exponential coordinates as well as their time derivatives in one shot. This mainly exists because ForwardDiff won't work at the singularity of  log . It is also ~50% faster than ForwardDiff in this case.  source", 
            "title": "Functions"
        }, 
        {
            "location": "/joints/", 
            "text": "Joints\n\n\n\n\nIndex\n\n\n\n\nRigidBodyDynamics.Fixed\n\n\nRigidBodyDynamics.Joint\n\n\nRigidBodyDynamics.Prismatic\n\n\nRigidBodyDynamics.Prismatic\n\n\nRigidBodyDynamics.QuaternionFloating\n\n\nRigidBodyDynamics.Revolute\n\n\nRigidBodyDynamics.Revolute\n\n\nRigidBodyDynamics.bias_acceleration\n\n\nRigidBodyDynamics.configuration_derivative_to_velocity!\n\n\nRigidBodyDynamics.constraint_wrench_subspace\n\n\nRigidBodyDynamics.global_coordinates!\n\n\nRigidBodyDynamics.has_fixed_subspaces\n\n\nRigidBodyDynamics.joint_torque!\n\n\nRigidBodyDynamics.joint_transform\n\n\nRigidBodyDynamics.joint_twist\n\n\nRigidBodyDynamics.local_coordinates!\n\n\nRigidBodyDynamics.motion_subspace\n\n\nRigidBodyDynamics.num_constraints\n\n\nRigidBodyDynamics.num_positions\n\n\nRigidBodyDynamics.num_velocities\n\n\nRigidBodyDynamics.rand_configuration!\n\n\nRigidBodyDynamics.velocity_to_configuration_derivative!\n\n\nRigidBodyDynamics.zero_configuration!\n\n\n\n\n\n\nThe \nJoint\n type\n\n\n#\n\n\nRigidBodyDynamics.Joint\n \n \nType\n.\n\n\ntype Joint{T\n:Number}\n\n\n\n\nA joint represents a kinematic restriction of the relative twist between two rigid bodies to a linear subspace of dimension $k$. The state related to the joint is parameterized by two sets of variables, namely\n\n\n\n\na vector $q \\in  \\mathcal{Q}$, parameterizing the relative homogeneous transform.\n\n\na vector $v \\in \\mathbb{R}^k$, parameterizing the relative twist.\n\n\n\n\nA joint has a direction. The rigid body before the joint is called the joint's predecessor, and the rigid body after the joint is its successor.\n\n\nThe twist of the successor with respect to the predecessor is a linear function of $v$.\n\n\nFor some joint types (notably those using a redundant representation of relative orientation, such as a unit quaternion), $\\dot{q}$, the time derivative of $q$, may not be the same as $v$. However, an invertible linear transformation exists between $\\dot{q}$ and $v$.\n\n\nSee also:\n\n\n\n\nDefinition 2.9 in Duindam, \"Port-Based Modeling and Control for Efficient Bipedal Walking Robots\", 2006.\n\n\nSection 4.4 of Featherstone, \"Rigid Body Dynamics Algorithms\", 2008.\n\n\n\n\nsource\n\n\n\n\nFunctions\n\n\n#\n\n\nRigidBodyDynamics.bias_acceleration\n \n \nMethod\n.\n\n\nbias_acceleration(joint, q, v)\n\n\n\n\n\nReturn the acceleration of the joint's successor with respect to its predecessor in configuration $q$ and at velocity $v$, when the joint acceleration $\\dot{v}$ is zero.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.configuration_derivative_to_velocity!\n \n \nMethod\n.\n\n\nconfiguration_derivative_to_velocity!(joint, v, q, q\u0307)\n\n\n\n\n\nCompute joint velocity vector $v$ given the joint configuration vector $q$ and its time derivative $\\dot{q}$ (in place).\n\n\nNote that this mapping is linear.\n\n\nSee also \nvelocity_to_configuration_derivative!\n, the inverse mapping.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.constraint_wrench_subspace\n \n \nMethod\n.\n\n\nconstraint_wrench_subspace(joint, jointTransform)\n\n\n\n\n\nReturn a basis for the constraint wrench subspace of the joint in configuration $q$.\n\n\nThe constraint wrench subspace is a $6 \\times (6 - k)$ matrix, where $k$ is the dimension of the velocity vector $v$, that maps a vector of Lagrange multipliers $\\lambda$ to the constraint wrench exerted across the joint onto its successor.\n\n\nThe constraint wrench subspace is orthogonal to the motion subspace.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.global_coordinates!\n \n \nMethod\n.\n\n\nglobal_coordinates!(joint, q, q0, \u03d5)\n\n\n\n\n\nCompute the global parameterization of the joint's configuration, $q$, given a 'base' orientation $q_0$ and a vector of local coordinates relative to $q_0$, $\u03d5$.\n\n\nSee also \nlocal_coordinates!\n.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.has_fixed_subspaces\n \n \nMethod\n.\n\n\nhas_fixed_subspaces(joint)\n\n\n\n\n\nWhether the joint's motion subspace and constraint wrench subspace depend on $q$.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.joint_torque!\n \n \nMethod\n.\n\n\njoint_torque!(joint, \u03c4, q, joint_wrench)\n\n\n\n\n\nGiven the wrench exerted across the joint on the joint's successor, compute the vector of joint torques $\\tau$ (in place), in configuration \nq\n.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.joint_transform\n \n \nMethod\n.\n\n\njoint_transform(joint, q)\n\n\n\n\n\nReturn a \nTransform3D\n representing the homogeneous transform from the frame after the joint to the frame before the joint for joint configuration vector $q$.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.local_coordinates!\n \n \nMethod\n.\n\n\nlocal_coordinates!(joint, \u03d5, \u03d5\u0307, q0, q, v)\n\n\n\n\n\nCompute a vector of local coordinates $\\phi$ around configuration $q_0$ corresponding to configuration $q$ (in place). Also compute the time derivative $\\dot{\\phi}$ of $\\phi$ given the joint velocity vector $v$.\n\n\nThe local coordinate vector $\\phi$ must be zero if and only if $q = q_0$.\n\n\nFor revolute or prismatic joint types, the local coordinates can just be $\\phi = q - q_0$, but for joint types with configuration vectors that are restricted to a manifold (e.g. when unit quaternions are used to represent orientation), elementwise subtraction may not make sense. For such joints, exponential coordinates could be used as the local coordinate vector $\\phi$.\n\n\nSee also \nglobal_coordinates!\n.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.motion_subspace\n \n \nMethod\n.\n\n\nmotion_subspace(joint, q)\n\n\n\n\n\nReturn a basis for the motion subspace of the joint in configuration $q$.\n\n\nThe motion subspace basis is a $6 \\times  k$ matrix, where $k$ is the dimension of the velocity vector $v$, that maps $v$ to the twist of the joint's successor with respect to its predecessor. The returned motion subspace is expressed in the frame after the joint, which is attached to the joint's successor.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.num_positions\n \n \nMethod\n.\n\n\nnum_positions(joint)\n\n\n\n\n\nReturn the length of the configuration vector of \njoint\n.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.num_velocities\n \n \nMethod\n.\n\n\nnum_velocities(joint)\n\n\n\n\n\nReturn the length of the velocity vector of \njoint\n.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.rand_configuration!\n \n \nMethod\n.\n\n\nrand_configuration!(joint, q)\n\n\n\n\n\nSet $q$ to a random configuration. The distribution used depends on the joint type.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.velocity_to_configuration_derivative!\n \n \nMethod\n.\n\n\nvelocity_to_configuration_derivative!(joint, q\u0307, q, v)\n\n\n\n\n\nCompute the time derivative $\\dot{q}$ of the joint configuration vector $q$ given $q$ and the joint velocity vector $v$ (in place).\n\n\nNote that this mapping is linear.\n\n\nSee also \nconfiguration_derivative_to_velocity!\n, the inverse mapping.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.zero_configuration!\n \n \nMethod\n.\n\n\nzero_configuration!(joint, q)\n\n\n\n\n\nSet $q$ to the 'zero' configuration, corresponding to an identity joint transform.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.joint_twist\n \n \nMethod\n.\n\n\njoint_twist(joint, q, v)\n\n\n\n\n\nReturn the twist of \njoint\n's  successor with respect to its predecessor, expressed in the frame after the joint.\n\n\nNote that this is the same as \nTwist(motion_subspace(joint, q), v)\n.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.num_constraints\n \n \nMethod\n.\n\n\nnum_constraints(joint)\n\n\n\n\n\nReturn the number of constraints imposed on the relative twist between the joint's predecessor and successor\n\n\nsource\n\n\n\n\nJointType\ns\n\n\n#\n\n\nRigidBodyDynamics.Fixed\n \n \nType\n.\n\n\nimmutable Fixed{T\n:Number} \n: RigidBodyDynamics.JointType{T\n:Number}\n\n\n\n\nThe \nFixed\n joint type is a degenerate joint type, in the sense that it allows no motion between its predecessor and successor rigid bodies.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.Prismatic\n \n \nType\n.\n\n\nimmutable Prismatic{T\n:Number} \n: RigidBodyDynamics.OneDegreeOfFreedomFixedAxis{T\n:Number}\n\n\n\n\nA \nPrismatic\n joint type allows translation along a fixed axis.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.Prismatic\n \n \nMethod\n.\n\n\nPrismatic(axis)\n\n\n\n\n\nConstruct a new \nPrismatic\n joint type, allowing translation along \naxis\n (expressed in the frame before the joint).\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.QuaternionFloating\n \n \nType\n.\n\n\nimmutable QuaternionFloating{T} \n: RigidBodyDynamics.JointType{T}\n\n\n\n\nA floating joint type that uses a unit quaternion representation for orientation.\n\n\nFloating joints are 6-degree-of-freedom joints that are in a sense degenerate, as they impose no constraints on the relative motion between two bodies.\n\n\nThe full, 7-dimensional configuration vector of a \nQuaternionFloating\n joint type consists of a unit quaternion representing the orientation that rotates vectors from the frame 'directly after' the joint to the frame 'directly before' it, and a 3D position vector representing the origin of the frame after the joint in the frame before the joint.\n\n\nThe 6-dimensional velocity vector of a \nQuaternionFloating\n joint is the twist of the frame after the joint with respect to the frame before it, expressed in the frame after the joint.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.Revolute\n \n \nType\n.\n\n\nimmutable Revolute{T\n:Number} \n: RigidBodyDynamics.OneDegreeOfFreedomFixedAxis{T\n:Number}\n\n\n\n\nA \nRevolute\n joint type allows rotation about a fixed axis.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.Revolute\n \n \nMethod\n.\n\n\nRevolute(axis)\n\n\n\n\n\nConstruct a new \nRevolute\n joint type, allowing rotation about \naxis\n (expressed in the frame before the joint).\n\n\nsource", 
            "title": "Joints"
        }, 
        {
            "location": "/joints/#joints", 
            "text": "", 
            "title": "Joints"
        }, 
        {
            "location": "/joints/#index", 
            "text": "RigidBodyDynamics.Fixed  RigidBodyDynamics.Joint  RigidBodyDynamics.Prismatic  RigidBodyDynamics.Prismatic  RigidBodyDynamics.QuaternionFloating  RigidBodyDynamics.Revolute  RigidBodyDynamics.Revolute  RigidBodyDynamics.bias_acceleration  RigidBodyDynamics.configuration_derivative_to_velocity!  RigidBodyDynamics.constraint_wrench_subspace  RigidBodyDynamics.global_coordinates!  RigidBodyDynamics.has_fixed_subspaces  RigidBodyDynamics.joint_torque!  RigidBodyDynamics.joint_transform  RigidBodyDynamics.joint_twist  RigidBodyDynamics.local_coordinates!  RigidBodyDynamics.motion_subspace  RigidBodyDynamics.num_constraints  RigidBodyDynamics.num_positions  RigidBodyDynamics.num_velocities  RigidBodyDynamics.rand_configuration!  RigidBodyDynamics.velocity_to_configuration_derivative!  RigidBodyDynamics.zero_configuration!", 
            "title": "Index"
        }, 
        {
            "location": "/joints/#the-joint-type", 
            "text": "#  RigidBodyDynamics.Joint     Type .  type Joint{T :Number}  A joint represents a kinematic restriction of the relative twist between two rigid bodies to a linear subspace of dimension $k$. The state related to the joint is parameterized by two sets of variables, namely   a vector $q \\in  \\mathcal{Q}$, parameterizing the relative homogeneous transform.  a vector $v \\in \\mathbb{R}^k$, parameterizing the relative twist.   A joint has a direction. The rigid body before the joint is called the joint's predecessor, and the rigid body after the joint is its successor.  The twist of the successor with respect to the predecessor is a linear function of $v$.  For some joint types (notably those using a redundant representation of relative orientation, such as a unit quaternion), $\\dot{q}$, the time derivative of $q$, may not be the same as $v$. However, an invertible linear transformation exists between $\\dot{q}$ and $v$.  See also:   Definition 2.9 in Duindam, \"Port-Based Modeling and Control for Efficient Bipedal Walking Robots\", 2006.  Section 4.4 of Featherstone, \"Rigid Body Dynamics Algorithms\", 2008.   source", 
            "title": "The Joint type"
        }, 
        {
            "location": "/joints/#functions", 
            "text": "#  RigidBodyDynamics.bias_acceleration     Method .  bias_acceleration(joint, q, v)  Return the acceleration of the joint's successor with respect to its predecessor in configuration $q$ and at velocity $v$, when the joint acceleration $\\dot{v}$ is zero.  source  #  RigidBodyDynamics.configuration_derivative_to_velocity!     Method .  configuration_derivative_to_velocity!(joint, v, q, q\u0307)  Compute joint velocity vector $v$ given the joint configuration vector $q$ and its time derivative $\\dot{q}$ (in place).  Note that this mapping is linear.  See also  velocity_to_configuration_derivative! , the inverse mapping.  source  #  RigidBodyDynamics.constraint_wrench_subspace     Method .  constraint_wrench_subspace(joint, jointTransform)  Return a basis for the constraint wrench subspace of the joint in configuration $q$.  The constraint wrench subspace is a $6 \\times (6 - k)$ matrix, where $k$ is the dimension of the velocity vector $v$, that maps a vector of Lagrange multipliers $\\lambda$ to the constraint wrench exerted across the joint onto its successor.  The constraint wrench subspace is orthogonal to the motion subspace.  source  #  RigidBodyDynamics.global_coordinates!     Method .  global_coordinates!(joint, q, q0, \u03d5)  Compute the global parameterization of the joint's configuration, $q$, given a 'base' orientation $q_0$ and a vector of local coordinates relative to $q_0$, $\u03d5$.  See also  local_coordinates! .  source  #  RigidBodyDynamics.has_fixed_subspaces     Method .  has_fixed_subspaces(joint)  Whether the joint's motion subspace and constraint wrench subspace depend on $q$.  source  #  RigidBodyDynamics.joint_torque!     Method .  joint_torque!(joint, \u03c4, q, joint_wrench)  Given the wrench exerted across the joint on the joint's successor, compute the vector of joint torques $\\tau$ (in place), in configuration  q .  source  #  RigidBodyDynamics.joint_transform     Method .  joint_transform(joint, q)  Return a  Transform3D  representing the homogeneous transform from the frame after the joint to the frame before the joint for joint configuration vector $q$.  source  #  RigidBodyDynamics.local_coordinates!     Method .  local_coordinates!(joint, \u03d5, \u03d5\u0307, q0, q, v)  Compute a vector of local coordinates $\\phi$ around configuration $q_0$ corresponding to configuration $q$ (in place). Also compute the time derivative $\\dot{\\phi}$ of $\\phi$ given the joint velocity vector $v$.  The local coordinate vector $\\phi$ must be zero if and only if $q = q_0$.  For revolute or prismatic joint types, the local coordinates can just be $\\phi = q - q_0$, but for joint types with configuration vectors that are restricted to a manifold (e.g. when unit quaternions are used to represent orientation), elementwise subtraction may not make sense. For such joints, exponential coordinates could be used as the local coordinate vector $\\phi$.  See also  global_coordinates! .  source  #  RigidBodyDynamics.motion_subspace     Method .  motion_subspace(joint, q)  Return a basis for the motion subspace of the joint in configuration $q$.  The motion subspace basis is a $6 \\times  k$ matrix, where $k$ is the dimension of the velocity vector $v$, that maps $v$ to the twist of the joint's successor with respect to its predecessor. The returned motion subspace is expressed in the frame after the joint, which is attached to the joint's successor.  source  #  RigidBodyDynamics.num_positions     Method .  num_positions(joint)  Return the length of the configuration vector of  joint .  source  #  RigidBodyDynamics.num_velocities     Method .  num_velocities(joint)  Return the length of the velocity vector of  joint .  source  #  RigidBodyDynamics.rand_configuration!     Method .  rand_configuration!(joint, q)  Set $q$ to a random configuration. The distribution used depends on the joint type.  source  #  RigidBodyDynamics.velocity_to_configuration_derivative!     Method .  velocity_to_configuration_derivative!(joint, q\u0307, q, v)  Compute the time derivative $\\dot{q}$ of the joint configuration vector $q$ given $q$ and the joint velocity vector $v$ (in place).  Note that this mapping is linear.  See also  configuration_derivative_to_velocity! , the inverse mapping.  source  #  RigidBodyDynamics.zero_configuration!     Method .  zero_configuration!(joint, q)  Set $q$ to the 'zero' configuration, corresponding to an identity joint transform.  source  #  RigidBodyDynamics.joint_twist     Method .  joint_twist(joint, q, v)  Return the twist of  joint 's  successor with respect to its predecessor, expressed in the frame after the joint.  Note that this is the same as  Twist(motion_subspace(joint, q), v) .  source  #  RigidBodyDynamics.num_constraints     Method .  num_constraints(joint)  Return the number of constraints imposed on the relative twist between the joint's predecessor and successor  source", 
            "title": "Functions"
        }, 
        {
            "location": "/joints/#jointtypes", 
            "text": "#  RigidBodyDynamics.Fixed     Type .  immutable Fixed{T :Number}  : RigidBodyDynamics.JointType{T :Number}  The  Fixed  joint type is a degenerate joint type, in the sense that it allows no motion between its predecessor and successor rigid bodies.  source  #  RigidBodyDynamics.Prismatic     Type .  immutable Prismatic{T :Number}  : RigidBodyDynamics.OneDegreeOfFreedomFixedAxis{T :Number}  A  Prismatic  joint type allows translation along a fixed axis.  source  #  RigidBodyDynamics.Prismatic     Method .  Prismatic(axis)  Construct a new  Prismatic  joint type, allowing translation along  axis  (expressed in the frame before the joint).  source  #  RigidBodyDynamics.QuaternionFloating     Type .  immutable QuaternionFloating{T}  : RigidBodyDynamics.JointType{T}  A floating joint type that uses a unit quaternion representation for orientation.  Floating joints are 6-degree-of-freedom joints that are in a sense degenerate, as they impose no constraints on the relative motion between two bodies.  The full, 7-dimensional configuration vector of a  QuaternionFloating  joint type consists of a unit quaternion representing the orientation that rotates vectors from the frame 'directly after' the joint to the frame 'directly before' it, and a 3D position vector representing the origin of the frame after the joint in the frame before the joint.  The 6-dimensional velocity vector of a  QuaternionFloating  joint is the twist of the frame after the joint with respect to the frame before it, expressed in the frame after the joint.  source  #  RigidBodyDynamics.Revolute     Type .  immutable Revolute{T :Number}  : RigidBodyDynamics.OneDegreeOfFreedomFixedAxis{T :Number}  A  Revolute  joint type allows rotation about a fixed axis.  source  #  RigidBodyDynamics.Revolute     Method .  Revolute(axis)  Construct a new  Revolute  joint type, allowing rotation about  axis  (expressed in the frame before the joint).  source", 
            "title": "JointTypes"
        }, 
        {
            "location": "/rigidbody/", 
            "text": "Rigid bodies\n\n\n\n\nIndex\n\n\n\n\nRigidBodyDynamics.RigidBody\n\n\nRigidBodyDynamics.add_frame!\n\n\nRigidBodyDynamics.change_default_frame!\n\n\nRigidBodyDynamics.default_frame\n\n\nRigidBodyDynamics.fixed_transform\n\n\nRigidBodyDynamics.frame_definition\n\n\nRigidBodyDynamics.frame_definitions\n\n\nRigidBodyDynamics.has_defined_inertia\n\n\nRigidBodyDynamics.is_fixed_to_body\n\n\nRigidBodyDynamics.spatial_inertia\n\n\nRigidBodyDynamics.spatial_inertia!\n\n\n\n\n\n\nThe \nRigidBody\n type\n\n\n#\n\n\nRigidBodyDynamics.RigidBody\n \n \nType\n.\n\n\ntype RigidBody{T\n:Number}\n\n\n\n\nA non-deformable body.\n\n\nA \nRigidBody\n has inertia (represented as a \nSpatialInertia\n), unless it represents a root (world) body. A \nRigidBody\n additionally stores a list of definitions of coordinate systems that are rigidly attached to it.\n\n\nsource\n\n\n\n\nFunctions\n\n\n#\n\n\nRigidBodyDynamics.add_frame!\n \n \nMethod\n.\n\n\nadd_frame!(body, transform)\n\n\n\n\n\nAdd a new frame definition to \nbody\n, represented by a homogeneous transform from the \nCartesianFrame3D\n to be added to any other frame that is already attached to \nbody\n.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.default_frame\n \n \nMethod\n.\n\n\ndefault_frame(body)\n\n\n\n\n\nThe \nCartesianFrame3D\n with respect to which all other frames attached to \nbody\n are defined.\n\n\nSee \nframe_definitions(body)\n, \nframe_definition(body, frame)\n.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.fixed_transform\n \n \nMethod\n.\n\n\nfixed_transform(body, from, to)\n\n\n\n\n\nReturn the transform from \nCartesianFrame3D\n \nfrom\n to \nto\n, both of which are rigidly attached to \nbody\n.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.has_defined_inertia\n \n \nMethod\n.\n\n\nhas_defined_inertia(b)\n\n\n\n\n\nWhether the body has a defined inertia.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.spatial_inertia!\n \n \nMethod\n.\n\n\nspatial_inertia!(body, inertia)\n\n\n\n\n\nSet the spatial inertia of the body.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.spatial_inertia\n \n \nMethod\n.\n\n\nspatial_inertia(b)\n\n\n\n\n\nReturn the spatial inertia of the body. If the inertia is undefined, calling this method will result in an error.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.change_default_frame!\n \n \nMethod\n.\n\n\nchange_default_frame!(body, newDefaultFrame)\n\n\n\n\n\nChange the default frame of \nbody\n to \nframe\n (which should already be among \nbody\n's frame definitions).\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.frame_definition\n \n \nMethod\n.\n\n\nframe_definition(body, frame)\n\n\n\n\n\nReturn the \nTransform3D\n defining \nframe\n (attached to \nbody\n) with respect to \ndefault_frame(body)\n.\n\n\nThrows an error if \nframe\n is not attached to \nbody\n.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.frame_definitions\n \n \nMethod\n.\n\n\nframe_definitions(body)\n\n\n\n\nReturn the list of homogeneous transforms (\nTransform3D\ns) that define the coordinate systems attached to \nbody\n with respect to a single common frame (\ndefault_frame(body)\n).\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.is_fixed_to_body\n \n \nMethod\n.\n\n\nis_fixed_to_body(body, frame)\n\n\n\n\n\nWhether \nframe\n is attached to \nbody\n (i.e. whether it is among \nframe_definitions(body)\n).\n\n\nsource", 
            "title": "Rigid bodies"
        }, 
        {
            "location": "/rigidbody/#rigid-bodies", 
            "text": "", 
            "title": "Rigid bodies"
        }, 
        {
            "location": "/rigidbody/#index", 
            "text": "RigidBodyDynamics.RigidBody  RigidBodyDynamics.add_frame!  RigidBodyDynamics.change_default_frame!  RigidBodyDynamics.default_frame  RigidBodyDynamics.fixed_transform  RigidBodyDynamics.frame_definition  RigidBodyDynamics.frame_definitions  RigidBodyDynamics.has_defined_inertia  RigidBodyDynamics.is_fixed_to_body  RigidBodyDynamics.spatial_inertia  RigidBodyDynamics.spatial_inertia!", 
            "title": "Index"
        }, 
        {
            "location": "/rigidbody/#the-rigidbody-type", 
            "text": "#  RigidBodyDynamics.RigidBody     Type .  type RigidBody{T :Number}  A non-deformable body.  A  RigidBody  has inertia (represented as a  SpatialInertia ), unless it represents a root (world) body. A  RigidBody  additionally stores a list of definitions of coordinate systems that are rigidly attached to it.  source", 
            "title": "The RigidBody type"
        }, 
        {
            "location": "/rigidbody/#functions", 
            "text": "#  RigidBodyDynamics.add_frame!     Method .  add_frame!(body, transform)  Add a new frame definition to  body , represented by a homogeneous transform from the  CartesianFrame3D  to be added to any other frame that is already attached to  body .  source  #  RigidBodyDynamics.default_frame     Method .  default_frame(body)  The  CartesianFrame3D  with respect to which all other frames attached to  body  are defined.  See  frame_definitions(body) ,  frame_definition(body, frame) .  source  #  RigidBodyDynamics.fixed_transform     Method .  fixed_transform(body, from, to)  Return the transform from  CartesianFrame3D   from  to  to , both of which are rigidly attached to  body .  source  #  RigidBodyDynamics.has_defined_inertia     Method .  has_defined_inertia(b)  Whether the body has a defined inertia.  source  #  RigidBodyDynamics.spatial_inertia!     Method .  spatial_inertia!(body, inertia)  Set the spatial inertia of the body.  source  #  RigidBodyDynamics.spatial_inertia     Method .  spatial_inertia(b)  Return the spatial inertia of the body. If the inertia is undefined, calling this method will result in an error.  source  #  RigidBodyDynamics.change_default_frame!     Method .  change_default_frame!(body, newDefaultFrame)  Change the default frame of  body  to  frame  (which should already be among  body 's frame definitions).  source  #  RigidBodyDynamics.frame_definition     Method .  frame_definition(body, frame)  Return the  Transform3D  defining  frame  (attached to  body ) with respect to  default_frame(body) .  Throws an error if  frame  is not attached to  body .  source  #  RigidBodyDynamics.frame_definitions     Method .  frame_definitions(body)  Return the list of homogeneous transforms ( Transform3D s) that define the coordinate systems attached to  body  with respect to a single common frame ( default_frame(body) ).  source  #  RigidBodyDynamics.is_fixed_to_body     Method .  is_fixed_to_body(body, frame)  Whether  frame  is attached to  body  (i.e. whether it is among  frame_definitions(body) ).  source", 
            "title": "Functions"
        }, 
        {
            "location": "/mechanism/", 
            "text": "Mechanisms\n\n\n\n\nIndex\n\n\n\n\nRigidBodyDynamics.Mechanism\n\n\nRigidBodyDynamics.TreeDataStructure.path\n\n\nRigidBodyDynamics.attach!\n\n\nRigidBodyDynamics.attach!\n\n\nRigidBodyDynamics.bodies\n\n\nRigidBodyDynamics.body_fixed_frame_definition\n\n\nRigidBodyDynamics.body_fixed_frame_to_body\n\n\nRigidBodyDynamics.fixed_transform\n\n\nRigidBodyDynamics.joints\n\n\nRigidBodyDynamics.maximal_coordinates\n\n\nRigidBodyDynamics.num_positions\n\n\nRigidBodyDynamics.num_velocities\n\n\nRigidBodyDynamics.parse_urdf\n\n\nRigidBodyDynamics.rand_chain_mechanism\n\n\nRigidBodyDynamics.rand_floating_tree_mechanism\n\n\nRigidBodyDynamics.rand_mechanism\n\n\nRigidBodyDynamics.rand_tree_mechanism\n\n\nRigidBodyDynamics.reattach!\n\n\nRigidBodyDynamics.remove_fixed_joints!\n\n\nRigidBodyDynamics.root_body\n\n\nRigidBodyDynamics.root_frame\n\n\nRigidBodyDynamics.submechanism\n\n\n\n\n\n\nThe \nMechanism\n type\n\n\n#\n\n\nRigidBodyDynamics.Mechanism\n \n \nType\n.\n\n\ntype Mechanism{T\n:Number}\n\n\n\n\nA \nMechanism\n represents an interconnection of rigid bodies and joints. \nMechanism\ns store the joint layout and inertia parameters, but no state-dependent information.\n\n\nsource\n\n\n\n\nBasic functionality\n\n\n#\n\n\nRigidBodyDynamics.TreeDataStructure.path\n \n \nMethod\n.\n\n\npath(mechanism, from, to)\n\n\n\n\n\nReturn the path from rigid body \nfrom\n to \nto\n along edges of the \nMechanism\n's kinematic tree.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.bodies\n \n \nMethod\n.\n\n\nbodies(mechanism)\n\n\n\n\n\nReturn the \nRigidBody\ns that are part of the \nMechanism\n as an iterable collection.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.fixed_transform\n \n \nMethod\n.\n\n\nfixed_transform(mechanism, from, to)\n\n\n\n\n\nReturn the transform from \nCartesianFrame3D\n \nfrom\n to \nto\n, both of which are rigidly attached to the same \nRigidBody\n.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.joints\n \n \nMethod\n.\n\n\njoints(mechanism)\n\n\n\n\n\nReturn the \nJoint\ns that are part of the \nMechanism\n as an iterable collection.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.num_positions\n \n \nMethod\n.\n\n\nnum_positions(mechanism)\n\n\n\n\n\nReturn the dimension of the joint configuration vector $q$.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.num_velocities\n \n \nMethod\n.\n\n\nnum_velocities(mechanism)\n\n\n\n\n\nReturn the dimension of the joint velocity vector $v$.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.root_body\n \n \nMethod\n.\n\n\nroot_body(mechanism)\n\n\n\n\n\nReturn the root (stationary 'world') body of the \nMechanism\n.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.root_frame\n \n \nMethod\n.\n\n\nroot_frame(mechanism)\n\n\n\n\n\nReturn the default frame of the root body.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.body_fixed_frame_definition\n \n \nMethod\n.\n\n\nbody_fixed_frame_definition(mechanism, frame)\n\n\n\n\n\nReturn the definition of body-fixed frame \nframe\n, i.e., the \nTransform3D\n from \nframe\n to the default frame of the body to which it is attached.\n\n\nSee also \ndefault_frame\n, \nframe_definition\n.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.body_fixed_frame_to_body\n \n \nMethod\n.\n\n\nbody_fixed_frame_to_body(mechanism, frame)\n\n\n\n\n\nReturn the \nRigidBody\n to which \nframe\n is attached.\n\n\nsource\n\n\n\n\nCreating and modifying \nMechanism\ns\n\n\n#\n\n\nRigidBodyDynamics.parse_urdf\n \n \nFunction\n.\n\n\nparse_urdf(scalartype, filename)\n\n\n\n\n\nCreate a \nMechanism\n by parsing a \nURDF\n file.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.attach!\n \n \nFunction\n.\n\n\nattach!(mechanism, predecessor, joint, jointToPredecessor, successor, successorToJoint)\n\n\n\n\nAttach \nsuccessor\n to \npredecessor\n using \njoint\n.\n\n\nSee \nJoint\n for definitions of the terms successor and predecessor.\n\n\nThe \nTransform3D\ns \njointToPredecessor\n and \nsuccessorToJoint\n define where \njoint\n is attached to each body. \njointToPredecessor\n should define \njoint.frameBefore\n with respect to any frame fixed to \npredecessor\n, and likewise \nsuccessorToJoint\n should define any frame fixed to \nsuccessor\n with respect to \njoint.frameAfter\n.\n\n\npredecessor\n is required to already be among the bodies of the \nMechanism\n.\n\n\nIf \nsuccessor\n is not yet a part of the \nMechanism\n, it will be added to the \nMechanism\n. Otherwise, the \njoint\n will be treated as a non-tree edge in the \nMechanism\n, effectively creating a loop constraint that will be enforced using Lagrange multipliers (as opposed to using recursive algorithms).\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.attach!\n \n \nMethod\n.\n\n\nattach!(mechanism, parentBody, childMechanism)\n\n\n\n\n\nAttach \nchildMechanism\n to \nmechanism\n.\n\n\nEssentially replaces the root body of \nchildMechanism\n with \nparentBody\n (which belongs to \nmechanism\n).\n\n\nCurrently doesn't support \nMechanism\ns with cycles.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.maximal_coordinates\n \n \nMethod\n.\n\n\nmaximal_coordinates(mechanism)\n\n\n\n\n\nReturn a dynamically equivalent \nMechanism\n, but with a flat tree structure with all bodies attached to the root body with a quaternion floating joint, and with the 'tree edge' joints of the input \nMechanism\n transformed into non-tree edge joints (a constraint enforced using Lagrange multipliers in \ndynamics!\n).\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.rand_chain_mechanism\n \n \nMethod\n.\n\n\nrand_chain_mechanism(t, jointTypes)\n\n\n\n\n\nCreate a random chain \nMechanism\n with the given joint types.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.rand_floating_tree_mechanism\n \n \nMethod\n.\n\n\nrand_floating_tree_mechanism(t, nonFloatingJointTypes)\n\n\n\n\n\nCreate a random tree \nMechanism\n (without loops), with a quaternion floating joint as the first joint (between the root body and the first non-root body).\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.rand_mechanism\n \n \nMethod\n.\n\n\nrand_mechanism(?, parentSelector, jointTypes)\n\n\n\n\n\nCreate a random \nMechanism\n with the given joint types. Each new body is attached to a parent selected using the \nparentSelector\n function.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.rand_tree_mechanism\n \n \nMethod\n.\n\n\nrand_tree_mechanism(t, jointTypes)\n\n\n\n\n\nCreate a random tree \nMechanism\n (without loops).\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.reattach!\n \n \nFunction\n.\n\n\nreattach!(mechanism, oldSubtreeRootBody, parentBody, joint, jointToParent, newSubtreeRootBody)\nreattach!(mechanism, oldSubtreeRootBody, parentBody, joint, jointToParent, newSubtreeRootBody, newSubTreeRootBodyToJoint)\n\n\n\n\n\nDetach the subtree rooted at \noldSubtreeRootBody\n, reroot it so that \nnewSubtreeRootBody\n is the new root, and then attach \nnewSubtreeRootBody\n to \nparentBody\n using \njoint\n.\n\n\nCurrently doesn't support \nMechanism\ns with cycles.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.remove_fixed_joints!\n \n \nMethod\n.\n\n\nremove_fixed_joints!(mechanism)\n\n\n\n\n\nRemove any fixed joints present as tree edges in \nmechanism\n by merging the rigid bodies that these fixed joints join together into bodies with equivalent inertial properties.\n\n\nCurrently doesn't support \nMechanism\ns with cycles.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.submechanism\n \n \nMethod\n.\n\n\nsubmechanism(mechanism, submechanismRootBody)\n\n\n\n\n\nCreate a \nMechanism\n from the subtree of \nmechanism\n rooted at \nsubmechanismRootBody\n.\n\n\nCurrently doesn't support \nMechanism\ns with cycles.\n\n\nsource", 
            "title": "Mechanism"
        }, 
        {
            "location": "/mechanism/#mechanisms", 
            "text": "", 
            "title": "Mechanisms"
        }, 
        {
            "location": "/mechanism/#index", 
            "text": "RigidBodyDynamics.Mechanism  RigidBodyDynamics.TreeDataStructure.path  RigidBodyDynamics.attach!  RigidBodyDynamics.attach!  RigidBodyDynamics.bodies  RigidBodyDynamics.body_fixed_frame_definition  RigidBodyDynamics.body_fixed_frame_to_body  RigidBodyDynamics.fixed_transform  RigidBodyDynamics.joints  RigidBodyDynamics.maximal_coordinates  RigidBodyDynamics.num_positions  RigidBodyDynamics.num_velocities  RigidBodyDynamics.parse_urdf  RigidBodyDynamics.rand_chain_mechanism  RigidBodyDynamics.rand_floating_tree_mechanism  RigidBodyDynamics.rand_mechanism  RigidBodyDynamics.rand_tree_mechanism  RigidBodyDynamics.reattach!  RigidBodyDynamics.remove_fixed_joints!  RigidBodyDynamics.root_body  RigidBodyDynamics.root_frame  RigidBodyDynamics.submechanism", 
            "title": "Index"
        }, 
        {
            "location": "/mechanism/#the-mechanism-type", 
            "text": "#  RigidBodyDynamics.Mechanism     Type .  type Mechanism{T :Number}  A  Mechanism  represents an interconnection of rigid bodies and joints.  Mechanism s store the joint layout and inertia parameters, but no state-dependent information.  source", 
            "title": "The Mechanism type"
        }, 
        {
            "location": "/mechanism/#basic-functionality", 
            "text": "#  RigidBodyDynamics.TreeDataStructure.path     Method .  path(mechanism, from, to)  Return the path from rigid body  from  to  to  along edges of the  Mechanism 's kinematic tree.  source  #  RigidBodyDynamics.bodies     Method .  bodies(mechanism)  Return the  RigidBody s that are part of the  Mechanism  as an iterable collection.  source  #  RigidBodyDynamics.fixed_transform     Method .  fixed_transform(mechanism, from, to)  Return the transform from  CartesianFrame3D   from  to  to , both of which are rigidly attached to the same  RigidBody .  source  #  RigidBodyDynamics.joints     Method .  joints(mechanism)  Return the  Joint s that are part of the  Mechanism  as an iterable collection.  source  #  RigidBodyDynamics.num_positions     Method .  num_positions(mechanism)  Return the dimension of the joint configuration vector $q$.  source  #  RigidBodyDynamics.num_velocities     Method .  num_velocities(mechanism)  Return the dimension of the joint velocity vector $v$.  source  #  RigidBodyDynamics.root_body     Method .  root_body(mechanism)  Return the root (stationary 'world') body of the  Mechanism .  source  #  RigidBodyDynamics.root_frame     Method .  root_frame(mechanism)  Return the default frame of the root body.  source  #  RigidBodyDynamics.body_fixed_frame_definition     Method .  body_fixed_frame_definition(mechanism, frame)  Return the definition of body-fixed frame  frame , i.e., the  Transform3D  from  frame  to the default frame of the body to which it is attached.  See also  default_frame ,  frame_definition .  source  #  RigidBodyDynamics.body_fixed_frame_to_body     Method .  body_fixed_frame_to_body(mechanism, frame)  Return the  RigidBody  to which  frame  is attached.  source", 
            "title": "Basic functionality"
        }, 
        {
            "location": "/mechanism/#creating-and-modifying-mechanisms", 
            "text": "#  RigidBodyDynamics.parse_urdf     Function .  parse_urdf(scalartype, filename)  Create a  Mechanism  by parsing a  URDF  file.  source  #  RigidBodyDynamics.attach!     Function .  attach!(mechanism, predecessor, joint, jointToPredecessor, successor, successorToJoint)  Attach  successor  to  predecessor  using  joint .  See  Joint  for definitions of the terms successor and predecessor.  The  Transform3D s  jointToPredecessor  and  successorToJoint  define where  joint  is attached to each body.  jointToPredecessor  should define  joint.frameBefore  with respect to any frame fixed to  predecessor , and likewise  successorToJoint  should define any frame fixed to  successor  with respect to  joint.frameAfter .  predecessor  is required to already be among the bodies of the  Mechanism .  If  successor  is not yet a part of the  Mechanism , it will be added to the  Mechanism . Otherwise, the  joint  will be treated as a non-tree edge in the  Mechanism , effectively creating a loop constraint that will be enforced using Lagrange multipliers (as opposed to using recursive algorithms).  source  #  RigidBodyDynamics.attach!     Method .  attach!(mechanism, parentBody, childMechanism)  Attach  childMechanism  to  mechanism .  Essentially replaces the root body of  childMechanism  with  parentBody  (which belongs to  mechanism ).  Currently doesn't support  Mechanism s with cycles.  source  #  RigidBodyDynamics.maximal_coordinates     Method .  maximal_coordinates(mechanism)  Return a dynamically equivalent  Mechanism , but with a flat tree structure with all bodies attached to the root body with a quaternion floating joint, and with the 'tree edge' joints of the input  Mechanism  transformed into non-tree edge joints (a constraint enforced using Lagrange multipliers in  dynamics! ).  source  #  RigidBodyDynamics.rand_chain_mechanism     Method .  rand_chain_mechanism(t, jointTypes)  Create a random chain  Mechanism  with the given joint types.  source  #  RigidBodyDynamics.rand_floating_tree_mechanism     Method .  rand_floating_tree_mechanism(t, nonFloatingJointTypes)  Create a random tree  Mechanism  (without loops), with a quaternion floating joint as the first joint (between the root body and the first non-root body).  source  #  RigidBodyDynamics.rand_mechanism     Method .  rand_mechanism(?, parentSelector, jointTypes)  Create a random  Mechanism  with the given joint types. Each new body is attached to a parent selected using the  parentSelector  function.  source  #  RigidBodyDynamics.rand_tree_mechanism     Method .  rand_tree_mechanism(t, jointTypes)  Create a random tree  Mechanism  (without loops).  source  #  RigidBodyDynamics.reattach!     Function .  reattach!(mechanism, oldSubtreeRootBody, parentBody, joint, jointToParent, newSubtreeRootBody)\nreattach!(mechanism, oldSubtreeRootBody, parentBody, joint, jointToParent, newSubtreeRootBody, newSubTreeRootBodyToJoint)  Detach the subtree rooted at  oldSubtreeRootBody , reroot it so that  newSubtreeRootBody  is the new root, and then attach  newSubtreeRootBody  to  parentBody  using  joint .  Currently doesn't support  Mechanism s with cycles.  source  #  RigidBodyDynamics.remove_fixed_joints!     Method .  remove_fixed_joints!(mechanism)  Remove any fixed joints present as tree edges in  mechanism  by merging the rigid bodies that these fixed joints join together into bodies with equivalent inertial properties.  Currently doesn't support  Mechanism s with cycles.  source  #  RigidBodyDynamics.submechanism     Method .  submechanism(mechanism, submechanismRootBody)  Create a  Mechanism  from the subtree of  mechanism  rooted at  submechanismRootBody .  Currently doesn't support  Mechanism s with cycles.  source", 
            "title": "Creating and modifying Mechanisms"
        }, 
        {
            "location": "/mechanismstate/", 
            "text": "MechanismState\n\n\n\n\nIndex\n\n\n\n\nRigidBodyDynamics.MechanismState\n\n\nBase.Random.rand!\n\n\nRigidBodyDynamics.configuration\n\n\nRigidBodyDynamics.configuration_vector\n\n\nRigidBodyDynamics.configuration_vector\n\n\nRigidBodyDynamics.num_positions\n\n\nRigidBodyDynamics.num_velocities\n\n\nRigidBodyDynamics.rand_configuration!\n\n\nRigidBodyDynamics.rand_velocity!\n\n\nRigidBodyDynamics.relative_transform\n\n\nRigidBodyDynamics.relative_twist\n\n\nRigidBodyDynamics.relative_twist\n\n\nRigidBodyDynamics.set_configuration!\n\n\nRigidBodyDynamics.set_configuration!\n\n\nRigidBodyDynamics.set_velocity!\n\n\nRigidBodyDynamics.set_velocity!\n\n\nRigidBodyDynamics.setdirty!\n\n\nRigidBodyDynamics.velocity\n\n\nRigidBodyDynamics.velocity_vector\n\n\nRigidBodyDynamics.velocity_vector\n\n\nRigidBodyDynamics.zero!\n\n\nRigidBodyDynamics.zero_configuration!\n\n\nRigidBodyDynamics.zero_velocity!\n\n\n\n\n\n\nThe \nMechanismState\n type\n\n\n#\n\n\nRigidBodyDynamics.MechanismState\n \n \nType\n.\n\n\nimmutable MechanismState{X\n:Number, M\n:Number, C\n:Number}\n\n\n\n\nA \nMechanismState\n stores state information for an entire \nMechanism\n. It contains the joint configuration and velocity vectors $q$ and $v$, as well as cache variables that depend on $q$ and $v$ and are aimed at preventing double work.\n\n\nsource\n\n\n\n\nFunctions\n\n\n#\n\n\nRigidBodyDynamics.configuration\n \n \nMethod\n.\n\n\nconfiguration(state, joint)\n\n\n\n\n\nReturn the part of the configuration vector $q$ associated with \njoint\n.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.configuration_vector\n \n \nMethod\n.\n\n\nconfiguration_vector(state, path)\n\n\n\n\n\nReturn the part of the \nMechanism\n's configuration vector $q$ associated with the joints on \npath\n.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.configuration_vector\n \n \nMethod\n.\n\n\nconfiguration_vector(state)\n\n\n\n\n\nReturn the configuration vector $q$.\n\n\nNote that this returns a reference to the underlying data in \nstate\n. The user is responsible for calling \nsetdirty!\n after modifying this vector to ensure that dependent cache variables are invalidated.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.num_positions\n \n \nMethod\n.\n\n\nnum_positions(state)\n\n\n\n\n\nReturn the length of the joint configuration vector $q$.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.num_velocities\n \n \nMethod\n.\n\n\nnum_velocities(state)\n\n\n\n\n\nReturn the length of the joint velocity vector $v$.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.rand_configuration!\n \n \nMethod\n.\n\n\nrand_configuration!(state)\n\n\n\n\n\nRandomize the configuration vector $q$. The distribution depends on the particular joint types present in the associated \nMechanism\n. The resulting $q$ is guaranteed to be on the \nMechanism\n's configuration manifold. Invalidates cache variables.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.rand_velocity!\n \n \nMethod\n.\n\n\nrand_velocity!(state)\n\n\n\n\n\nRandomize the velocity vector $v$. Invalidates cache variables.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.relative_transform\n \n \nMethod\n.\n\n\nrelative_transform(state, from, to)\n\n\n\n\n\nReturn the homogeneous transform from \nfrom\n to \nto\n.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.relative_twist\n \n \nMethod\n.\n\n\nrelative_twist(state, bodyFrame, baseFrame)\n\n\n\n\n\nReturn the twist of \nbodyFrame\n with respect to \nbaseFrame\n, expressed in the \nMechanism\n's root frame.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.relative_twist\n \n \nMethod\n.\n\n\nrelative_twist(state, body, base)\n\n\n\n\n\nReturn the twist of \nbody\n with respect to \nbase\n, expressed in the \nMechanism\n's root frame.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.set_configuration!\n \n \nMethod\n.\n\n\nset_configuration!(state, q)\n\n\n\n\n\nSet the configuration vector $q$. Invalidates cache variables.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.set_configuration!\n \n \nMethod\n.\n\n\nset_configuration!(state, joint, q)\n\n\n\n\n\nSet the part of the configuration vector associated with \njoint\n. Invalidates cache variables.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.set_velocity!\n \n \nMethod\n.\n\n\nset_velocity!(state, v)\n\n\n\n\n\nSet the velocity vector $v$. Invalidates cache variables.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.set_velocity!\n \n \nMethod\n.\n\n\nset_velocity!(state, joint, v)\n\n\n\n\n\nSet the part of the velocity vector associated with \njoint\n. Invalidates cache variables.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.setdirty!\n \n \nMethod\n.\n\n\nsetdirty!(state)\n\n\n\n\n\nInvalidate all cache variables.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.velocity\n \n \nMethod\n.\n\n\nvelocity(state, joint)\n\n\n\n\n\nReturn the part of the velocity vector $v$ associated with \njoint\n.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.velocity_vector\n \n \nMethod\n.\n\n\nvelocity_vector(state, path)\n\n\n\n\n\nReturn the part of the \nMechanism\n's velocity vector $v$ associated with the joints on \npath\n.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.velocity_vector\n \n \nMethod\n.\n\n\nvelocity_vector(state)\n\n\n\n\n\nReturn the velocity vector $v$.\n\n\nNote that this function returns a read-write reference to a field in \nstate\n. The user is responsible for calling \nsetdirty!\n after modifying this vector to ensure that dependent cache variables are invalidated.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.zero!\n \n \nMethod\n.\n\n\nzero!(state)\n\n\n\n\n\nZero both the configuration and velocity. Invalidates cache variables.\n\n\nSee \nzero_configuration!\n, \nzero_velocity!\n.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.zero_configuration!\n \n \nMethod\n.\n\n\nzero_configuration!(state)\n\n\n\n\n\n'Zero' the configuration vector $q$. Invalidates cache variables.\n\n\nNote that when the \nMechanism\n contains e.g. quaternion-parameterized joints, $q$ may not actually be set to all zeros; the quaternion part of the configuration vector would be set to identity. The contract is that each of the joint transforms should be an identity transform.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.zero_velocity!\n \n \nMethod\n.\n\n\nzero_velocity!(state)\n\n\n\n\n\nZero the velocity vector $v$. Invalidates cache variables.\n\n\nsource\n\n\n#\n\n\nBase.Random.rand!\n \n \nMethod\n.\n\n\nrand!(state)\n\n\n\n\n\nRandomize both the configuration and velocity. Invalidates cache variables.\n\n\nsource", 
            "title": "MechanismState"
        }, 
        {
            "location": "/mechanismstate/#mechanismstate", 
            "text": "", 
            "title": "MechanismState"
        }, 
        {
            "location": "/mechanismstate/#index", 
            "text": "RigidBodyDynamics.MechanismState  Base.Random.rand!  RigidBodyDynamics.configuration  RigidBodyDynamics.configuration_vector  RigidBodyDynamics.configuration_vector  RigidBodyDynamics.num_positions  RigidBodyDynamics.num_velocities  RigidBodyDynamics.rand_configuration!  RigidBodyDynamics.rand_velocity!  RigidBodyDynamics.relative_transform  RigidBodyDynamics.relative_twist  RigidBodyDynamics.relative_twist  RigidBodyDynamics.set_configuration!  RigidBodyDynamics.set_configuration!  RigidBodyDynamics.set_velocity!  RigidBodyDynamics.set_velocity!  RigidBodyDynamics.setdirty!  RigidBodyDynamics.velocity  RigidBodyDynamics.velocity_vector  RigidBodyDynamics.velocity_vector  RigidBodyDynamics.zero!  RigidBodyDynamics.zero_configuration!  RigidBodyDynamics.zero_velocity!", 
            "title": "Index"
        }, 
        {
            "location": "/mechanismstate/#the-mechanismstate-type", 
            "text": "#  RigidBodyDynamics.MechanismState     Type .  immutable MechanismState{X :Number, M :Number, C :Number}  A  MechanismState  stores state information for an entire  Mechanism . It contains the joint configuration and velocity vectors $q$ and $v$, as well as cache variables that depend on $q$ and $v$ and are aimed at preventing double work.  source", 
            "title": "The MechanismState type"
        }, 
        {
            "location": "/mechanismstate/#functions", 
            "text": "#  RigidBodyDynamics.configuration     Method .  configuration(state, joint)  Return the part of the configuration vector $q$ associated with  joint .  source  #  RigidBodyDynamics.configuration_vector     Method .  configuration_vector(state, path)  Return the part of the  Mechanism 's configuration vector $q$ associated with the joints on  path .  source  #  RigidBodyDynamics.configuration_vector     Method .  configuration_vector(state)  Return the configuration vector $q$.  Note that this returns a reference to the underlying data in  state . The user is responsible for calling  setdirty!  after modifying this vector to ensure that dependent cache variables are invalidated.  source  #  RigidBodyDynamics.num_positions     Method .  num_positions(state)  Return the length of the joint configuration vector $q$.  source  #  RigidBodyDynamics.num_velocities     Method .  num_velocities(state)  Return the length of the joint velocity vector $v$.  source  #  RigidBodyDynamics.rand_configuration!     Method .  rand_configuration!(state)  Randomize the configuration vector $q$. The distribution depends on the particular joint types present in the associated  Mechanism . The resulting $q$ is guaranteed to be on the  Mechanism 's configuration manifold. Invalidates cache variables.  source  #  RigidBodyDynamics.rand_velocity!     Method .  rand_velocity!(state)  Randomize the velocity vector $v$. Invalidates cache variables.  source  #  RigidBodyDynamics.relative_transform     Method .  relative_transform(state, from, to)  Return the homogeneous transform from  from  to  to .  source  #  RigidBodyDynamics.relative_twist     Method .  relative_twist(state, bodyFrame, baseFrame)  Return the twist of  bodyFrame  with respect to  baseFrame , expressed in the  Mechanism 's root frame.  source  #  RigidBodyDynamics.relative_twist     Method .  relative_twist(state, body, base)  Return the twist of  body  with respect to  base , expressed in the  Mechanism 's root frame.  source  #  RigidBodyDynamics.set_configuration!     Method .  set_configuration!(state, q)  Set the configuration vector $q$. Invalidates cache variables.  source  #  RigidBodyDynamics.set_configuration!     Method .  set_configuration!(state, joint, q)  Set the part of the configuration vector associated with  joint . Invalidates cache variables.  source  #  RigidBodyDynamics.set_velocity!     Method .  set_velocity!(state, v)  Set the velocity vector $v$. Invalidates cache variables.  source  #  RigidBodyDynamics.set_velocity!     Method .  set_velocity!(state, joint, v)  Set the part of the velocity vector associated with  joint . Invalidates cache variables.  source  #  RigidBodyDynamics.setdirty!     Method .  setdirty!(state)  Invalidate all cache variables.  source  #  RigidBodyDynamics.velocity     Method .  velocity(state, joint)  Return the part of the velocity vector $v$ associated with  joint .  source  #  RigidBodyDynamics.velocity_vector     Method .  velocity_vector(state, path)  Return the part of the  Mechanism 's velocity vector $v$ associated with the joints on  path .  source  #  RigidBodyDynamics.velocity_vector     Method .  velocity_vector(state)  Return the velocity vector $v$.  Note that this function returns a read-write reference to a field in  state . The user is responsible for calling  setdirty!  after modifying this vector to ensure that dependent cache variables are invalidated.  source  #  RigidBodyDynamics.zero!     Method .  zero!(state)  Zero both the configuration and velocity. Invalidates cache variables.  See  zero_configuration! ,  zero_velocity! .  source  #  RigidBodyDynamics.zero_configuration!     Method .  zero_configuration!(state)  'Zero' the configuration vector $q$. Invalidates cache variables.  Note that when the  Mechanism  contains e.g. quaternion-parameterized joints, $q$ may not actually be set to all zeros; the quaternion part of the configuration vector would be set to identity. The contract is that each of the joint transforms should be an identity transform.  source  #  RigidBodyDynamics.zero_velocity!     Method .  zero_velocity!(state)  Zero the velocity vector $v$. Invalidates cache variables.  source  #  Base.Random.rand!     Method .  rand!(state)  Randomize both the configuration and velocity. Invalidates cache variables.  source", 
            "title": "Functions"
        }, 
        {
            "location": "/algorithms/", 
            "text": "Algorithms\n\n\n\n\nIndex\n\n\n\n\nRigidBodyDynamics.DynamicsResult\n\n\nRigidBodyDynamics.center_of_mass\n\n\nRigidBodyDynamics.center_of_mass\n\n\nRigidBodyDynamics.dynamics!\n\n\nRigidBodyDynamics.dynamics!\n\n\nRigidBodyDynamics.dynamics_bias!\n\n\nRigidBodyDynamics.geometric_jacobian\n\n\nRigidBodyDynamics.gravitational_potential_energy\n\n\nRigidBodyDynamics.inverse_dynamics\n\n\nRigidBodyDynamics.inverse_dynamics!\n\n\nRigidBodyDynamics.mass\n\n\nRigidBodyDynamics.mass_matrix\n\n\nRigidBodyDynamics.mass_matrix!\n\n\nRigidBodyDynamics.momentum_matrix\n\n\nRigidBodyDynamics.momentum_matrix!\n\n\nRigidBodyDynamics.relative_acceleration\n\n\nRigidBodyDynamics.subtree_mass\n\n\n\n\n\n\nThe \nDynamicsResult\n type\n\n\n#\n\n\nRigidBodyDynamics.DynamicsResult\n \n \nType\n.\n\n\ntype DynamicsResult{M, T}\n\n\n\n\nStores variables related to the dynamics of a \nMechanism\n, e.g. the \nMechanism\n's mass matrix and joint acceleration vector.\n\n\nsource\n\n\n\n\nFunctions\n\n\n#\n\n\nRigidBodyDynamics.center_of_mass\n \n \nMethod\n.\n\n\ncenter_of_mass(state, itr)\n\n\n\n\n\nCompute the center of mass of an iterable subset of a \nMechanism\n's bodies in the given state.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.center_of_mass\n \n \nMethod\n.\n\n\ncenter_of_mass(state)\n\n\n\n\n\nCompute the center of mass of the whole \nMechanism\n in the given state.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.dynamics!\n \n \nFunction\n.\n\n\ndynamics!(result, state, torques, externalWrenches)\ndynamics!(result, state, torques)\ndynamics!(result, state)\n\n\n\n\n\nCompute the joint acceleration vector $\\dot{v}$ and Lagrange multipliers $\\lambda$ that satisfy the joint-space equations of motion\n\n\n\n\n\nM(q) \\dot{v} + c(q, v, w_\\text{ext}) = \\tau - K(q)^{T} \\lambda\n\n\n\n\n\nand the constraint equations\n\n\n\n\n\nK(q) \\dot{v} = -k\n\n\n\n\n\ngiven joint configuration vector $q$, joint velocity vector $v$, and (optionally) joint torques $\\tau$ and external wrenches $w_\\text{ext}$.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.dynamics!\n \n \nFunction\n.\n\n\ndynamics!(\u1e8b, result, state, stateVec)\ndynamics!(\u1e8b, result, state, stateVec, torques, externalWrenches)\ndynamics!(\u1e8b, result, state, stateVec, torques)\n\n\n\n\n\nConvenience function for use with standard ODE integrators that takes a \nVector\n argument\n\n\n\n\n\nx = \\left(\\begin{array}{c}\nq\\\\\nv\n\\end{array}\\right)\n\n\n\n\n\nand returns a \nVector\n $\\dot{x}$.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.geometric_jacobian\n \n \nMethod\n.\n\n\ngeometric_jacobian(state, path)\n\n\n\n\n\nCompute a geometric Jacobian (also known as a basic, or spatial Jacobian) for a path in the graph of joints and bodies of a \nMechanism\n, in the given state.\n\n\nSee also \npath\n, \nGeometricJacobian\n.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.gravitational_potential_energy\n \n \nMethod\n.\n\n\ngravitational_potential_energy(state)\n\n\n\n\n\nCompute the gravitational potential energy in the given state, computed as the negation of the dot product of the gravitational force and the center of mass expressed in the \nMechanism\n's root frame.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.inverse_dynamics\n \n \nFunction\n.\n\n\ninverse_dynamics(state, v\u0307)\ninverse_dynamics(state, v\u0307, externalWrenches)\n\n\n\n\n\nDo inverse dynamics, i.e. compute $\\tau$ in the unconstrained joint-space equations of motion\n\n\n\n\n\nM(q) \\dot{v} + c(q, v, w_\\text{ext}) = \\tau\n\n\n\n\n\ngiven joint configuration vector $q$, joint velocity vector $v$, joint acceleration vector $\\dot{v}$ and (optionally) external wrenches $w_\\text{ext}$.\n\n\nThis method implements the recursive Newton-Euler algorithm.\n\n\nCurrently doesn't support \nMechanism\ns with cycles.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.inverse_dynamics!\n \n \nFunction\n.\n\n\ninverse_dynamics!(torquesOut, jointWrenchesOut, accelerations, state, v\u0307)\ninverse_dynamics!(torquesOut, jointWrenchesOut, accelerations, state, v\u0307, externalWrenches)\n\n\n\n\n\nDo inverse dynamics, i.e. compute $\\tau$ in the unconstrained joint-space equations of motion\n\n\n\n\n\nM(q) \\dot{v} + c(q, v, w_\\text{ext}) = \\tau\n\n\n\n\n\ngiven joint configuration vector $q$, joint velocity vector $v$, joint acceleration vector $\\dot{v}$ and (optionally) external wrenches $w_\\text{ext}$.\n\n\nThis method implements the recursive Newton-Euler algorithm.\n\n\nCurrently doesn't support \nMechanism\ns with cycles.\n\n\nThis method does its computation in place, performing no dynamic memory allocation.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.mass\n \n \nMethod\n.\n\n\nmass(m)\n\n\n\n\n\nReturn the total mass of the \nMechanism\n.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.mass_matrix!\n \n \nMethod\n.\n\n\nmass_matrix!(out, state)\n\n\n\n\n\nCompute the joint-space mass matrix (also known as the inertia matrix) of the \nMechanism\n in the given state, i.e., the matrix $M(q)$ in the unconstrained joint-space equations of motion\n\n\n\n\n\nM(q) \\dot{v} + c(q, v, w_\\text{ext}) = \\tau\n\n\n\n\n\nThis method implements the composite rigid body algorithm.\n\n\nThis method does its computation in place, performing no dynamic memory allocation.\n\n\nThe \nout\n argument must be an $n_v \\times n_v$ lower triangular \nSymmetric\n matrix, where $n_v$ is the dimension of the \nMechanism\n's joint velocity vector $v$.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.mass_matrix\n \n \nMethod\n.\n\n\nmass_matrix(state)\n\n\n\n\n\nCompute the joint-space mass matrix (also known as the inertia matrix) of the \nMechanism\n in the given state, i.e., the matrix $M(q)$ in the unconstrained joint-space equations of motion\n\n\n\n\n\nM(q) \\dot{v} + c(q, v, w_\\text{ext}) = \\tau\n\n\n\n\n\nThis method implements the composite rigid body algorithm.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.momentum_matrix!\n \n \nMethod\n.\n\n\nmomentum_matrix!(out, state)\n\n\n\n\n\nCompute the momentum matrix $A(q)$ of the \nMechanism\n in the given state.\n\n\nThe momentum matrix maps the \nMechanism\n's joint velocity vector $v$ to its total momentum.\n\n\nThis method does its computation in place, performing no dynamic memory allocation.\n\n\nThe \nout\n argument must be a mutable \nMomentumMatrix\n with as many columns as the dimension of the \nMechanism\n's joint velocity vector $v$.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.momentum_matrix\n \n \nMethod\n.\n\n\nmomentum_matrix(state)\n\n\n\n\n\nCompute the momentum matrix $A(q)$ of the \nMechanism\n in the given state.\n\n\nThe momentum matrix maps the \nMechanism\n's joint velocity vector $v$ to its total momentum.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.relative_acceleration\n \n \nMethod\n.\n\n\nrelative_acceleration(state, body, base, v\u0307)\n\n\n\n\n\nCompute the spatial acceleration of \nbody\n with respect to \nbase\n for the given state and joint acceleration vector $\\dot{v}$.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.dynamics_bias!\n \n \nFunction\n.\n\n\ndynamics_bias!(torques, biasAccelerations, wrenches, state, externalWrenches)\ndynamics_bias!(torques, biasAccelerations, wrenches, state)\n\n\n\n\n\nCompute the 'dynamics bias term', i.e. the term\n\n\n\n\n\nc(q, v, w_\\text{ext})\n\n\n\n\n\nin the unconstrained joint-space equations of motion\n\n\n\n\n\nM(q) \\dot{v} + c(q, v, w_\\text{ext}) = \\tau\n\n\n\n\n\nThis method does its computation in place, performing no dynamic memory allocation.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.subtree_mass\n \n \nMethod\n.\n\n\nsubtree_mass(base)\n\n\n\n\n\nReturn the mass of a subtree of a \nMechanism\n, rooted at \nbase\n (including the mass of \nbase\n).\n\n\nsource", 
            "title": "Kinematics/dynamics algorithms"
        }, 
        {
            "location": "/algorithms/#algorithms", 
            "text": "", 
            "title": "Algorithms"
        }, 
        {
            "location": "/algorithms/#index", 
            "text": "RigidBodyDynamics.DynamicsResult  RigidBodyDynamics.center_of_mass  RigidBodyDynamics.center_of_mass  RigidBodyDynamics.dynamics!  RigidBodyDynamics.dynamics!  RigidBodyDynamics.dynamics_bias!  RigidBodyDynamics.geometric_jacobian  RigidBodyDynamics.gravitational_potential_energy  RigidBodyDynamics.inverse_dynamics  RigidBodyDynamics.inverse_dynamics!  RigidBodyDynamics.mass  RigidBodyDynamics.mass_matrix  RigidBodyDynamics.mass_matrix!  RigidBodyDynamics.momentum_matrix  RigidBodyDynamics.momentum_matrix!  RigidBodyDynamics.relative_acceleration  RigidBodyDynamics.subtree_mass", 
            "title": "Index"
        }, 
        {
            "location": "/algorithms/#the-dynamicsresult-type", 
            "text": "#  RigidBodyDynamics.DynamicsResult     Type .  type DynamicsResult{M, T}  Stores variables related to the dynamics of a  Mechanism , e.g. the  Mechanism 's mass matrix and joint acceleration vector.  source", 
            "title": "The DynamicsResult type"
        }, 
        {
            "location": "/algorithms/#functions", 
            "text": "#  RigidBodyDynamics.center_of_mass     Method .  center_of_mass(state, itr)  Compute the center of mass of an iterable subset of a  Mechanism 's bodies in the given state.  source  #  RigidBodyDynamics.center_of_mass     Method .  center_of_mass(state)  Compute the center of mass of the whole  Mechanism  in the given state.  source  #  RigidBodyDynamics.dynamics!     Function .  dynamics!(result, state, torques, externalWrenches)\ndynamics!(result, state, torques)\ndynamics!(result, state)  Compute the joint acceleration vector $\\dot{v}$ and Lagrange multipliers $\\lambda$ that satisfy the joint-space equations of motion   \nM(q) \\dot{v} + c(q, v, w_\\text{ext}) = \\tau - K(q)^{T} \\lambda   and the constraint equations   \nK(q) \\dot{v} = -k   given joint configuration vector $q$, joint velocity vector $v$, and (optionally) joint torques $\\tau$ and external wrenches $w_\\text{ext}$.  source  #  RigidBodyDynamics.dynamics!     Function .  dynamics!(\u1e8b, result, state, stateVec)\ndynamics!(\u1e8b, result, state, stateVec, torques, externalWrenches)\ndynamics!(\u1e8b, result, state, stateVec, torques)  Convenience function for use with standard ODE integrators that takes a  Vector  argument   \nx = \\left(\\begin{array}{c}\nq\\\\\nv\n\\end{array}\\right)   and returns a  Vector  $\\dot{x}$.  source  #  RigidBodyDynamics.geometric_jacobian     Method .  geometric_jacobian(state, path)  Compute a geometric Jacobian (also known as a basic, or spatial Jacobian) for a path in the graph of joints and bodies of a  Mechanism , in the given state.  See also  path ,  GeometricJacobian .  source  #  RigidBodyDynamics.gravitational_potential_energy     Method .  gravitational_potential_energy(state)  Compute the gravitational potential energy in the given state, computed as the negation of the dot product of the gravitational force and the center of mass expressed in the  Mechanism 's root frame.  source  #  RigidBodyDynamics.inverse_dynamics     Function .  inverse_dynamics(state, v\u0307)\ninverse_dynamics(state, v\u0307, externalWrenches)  Do inverse dynamics, i.e. compute $\\tau$ in the unconstrained joint-space equations of motion   \nM(q) \\dot{v} + c(q, v, w_\\text{ext}) = \\tau   given joint configuration vector $q$, joint velocity vector $v$, joint acceleration vector $\\dot{v}$ and (optionally) external wrenches $w_\\text{ext}$.  This method implements the recursive Newton-Euler algorithm.  Currently doesn't support  Mechanism s with cycles.  source  #  RigidBodyDynamics.inverse_dynamics!     Function .  inverse_dynamics!(torquesOut, jointWrenchesOut, accelerations, state, v\u0307)\ninverse_dynamics!(torquesOut, jointWrenchesOut, accelerations, state, v\u0307, externalWrenches)  Do inverse dynamics, i.e. compute $\\tau$ in the unconstrained joint-space equations of motion   \nM(q) \\dot{v} + c(q, v, w_\\text{ext}) = \\tau   given joint configuration vector $q$, joint velocity vector $v$, joint acceleration vector $\\dot{v}$ and (optionally) external wrenches $w_\\text{ext}$.  This method implements the recursive Newton-Euler algorithm.  Currently doesn't support  Mechanism s with cycles.  This method does its computation in place, performing no dynamic memory allocation.  source  #  RigidBodyDynamics.mass     Method .  mass(m)  Return the total mass of the  Mechanism .  source  #  RigidBodyDynamics.mass_matrix!     Method .  mass_matrix!(out, state)  Compute the joint-space mass matrix (also known as the inertia matrix) of the  Mechanism  in the given state, i.e., the matrix $M(q)$ in the unconstrained joint-space equations of motion   \nM(q) \\dot{v} + c(q, v, w_\\text{ext}) = \\tau   This method implements the composite rigid body algorithm.  This method does its computation in place, performing no dynamic memory allocation.  The  out  argument must be an $n_v \\times n_v$ lower triangular  Symmetric  matrix, where $n_v$ is the dimension of the  Mechanism 's joint velocity vector $v$.  source  #  RigidBodyDynamics.mass_matrix     Method .  mass_matrix(state)  Compute the joint-space mass matrix (also known as the inertia matrix) of the  Mechanism  in the given state, i.e., the matrix $M(q)$ in the unconstrained joint-space equations of motion   \nM(q) \\dot{v} + c(q, v, w_\\text{ext}) = \\tau   This method implements the composite rigid body algorithm.  source  #  RigidBodyDynamics.momentum_matrix!     Method .  momentum_matrix!(out, state)  Compute the momentum matrix $A(q)$ of the  Mechanism  in the given state.  The momentum matrix maps the  Mechanism 's joint velocity vector $v$ to its total momentum.  This method does its computation in place, performing no dynamic memory allocation.  The  out  argument must be a mutable  MomentumMatrix  with as many columns as the dimension of the  Mechanism 's joint velocity vector $v$.  source  #  RigidBodyDynamics.momentum_matrix     Method .  momentum_matrix(state)  Compute the momentum matrix $A(q)$ of the  Mechanism  in the given state.  The momentum matrix maps the  Mechanism 's joint velocity vector $v$ to its total momentum.  source  #  RigidBodyDynamics.relative_acceleration     Method .  relative_acceleration(state, body, base, v\u0307)  Compute the spatial acceleration of  body  with respect to  base  for the given state and joint acceleration vector $\\dot{v}$.  source  #  RigidBodyDynamics.dynamics_bias!     Function .  dynamics_bias!(torques, biasAccelerations, wrenches, state, externalWrenches)\ndynamics_bias!(torques, biasAccelerations, wrenches, state)  Compute the 'dynamics bias term', i.e. the term   \nc(q, v, w_\\text{ext})   in the unconstrained joint-space equations of motion   \nM(q) \\dot{v} + c(q, v, w_\\text{ext}) = \\tau   This method does its computation in place, performing no dynamic memory allocation.  source  #  RigidBodyDynamics.subtree_mass     Method .  subtree_mass(base)  Return the mass of a subtree of a  Mechanism , rooted at  base  (including the mass of  base ).  source", 
            "title": "Functions"
        }, 
        {
            "location": "/simulation/", 
            "text": "Simulation\n\n\n\n\nIndex\n\n\n\n\nRigidBodyDynamics.OdeIntegrators.ButcherTableau\n\n\nRigidBodyDynamics.OdeIntegrators.ExpandingStorage\n\n\nRigidBodyDynamics.OdeIntegrators.MuntheKaasIntegrator\n\n\nRigidBodyDynamics.OdeIntegrators.OdeResultsSink\n\n\nRigidBodyDynamics.OdeIntegrators.RingBufferStorage\n\n\nBase.step\n\n\nRigidBodyDynamics.OdeIntegrators.integrate\n\n\nRigidBodyDynamics.OdeIntegrators.runge_kutta_4\n\n\nRigidBodyDynamics.simulate\n\n\n\n\n\n\nBasic simulation\n\n\n#\n\n\nRigidBodyDynamics.simulate\n \n \nFunction\n.\n\n\nsimulate(state0, finalTime; \u0394t)\n\n\n\n\n\nSimple \nMechanism\n simulation: integrate the state from time $0$ to \nfinalTime\n starting from the initial state \nstate0\n. Return a \nVector\n of times, as well as \nVector\ns of configuration vectors and velocity vectors at these times.\n\n\nUses \nMuntheKaasIntegrator\n. See \nMuntheKaasIntegrator\n for a lower level interface with more options.\n\n\nsource\n\n\n\n\nLower level ODE integration interface\n\n\n#\n\n\nRigidBodyDynamics.OdeIntegrators.ExpandingStorage\n \n \nType\n.\n\n\ntype ExpandingStorage{T} \n: RigidBodyDynamics.OdeIntegrators.OdeResultsSink\n\n\n\n\nAn \nOdeResultsSink\n that stores the state at each integration time step in \nVectors\n that may expand.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.OdeIntegrators.MuntheKaasIntegrator\n \n \nType\n.\n\n\nA Lie-group-aware ODE integrator.\n\n\nMuntheKaasIntegrator\n is used to properly integrate the dynamics of globally parameterized rigid joints (Duindam, Port-Based Modeling and Control for Efficient Bipedal Walking Robots, 2006, Definition 2.9). Global parameterizations of e.g. $SO(3)$ are needed to avoid singularities, but this leads to the problem that the tangent space no longer has the same dimension as the ambient space of the global parameterization. A Munthe-Kaas integrator solves this problem by converting back and forth between local and global coordinates at every integration time step.\n\n\nThe idea is to do the dynamics and compute the stages of the integration scheme in terms of local coordinates centered around the global parameterization of the configuration at the end of the previous time step (e.g. exponential coordinates), combine the stages into a new set of local coordinates as usual for Runge-Kutta methods, and then convert the local coordinates back to global coordinates.\n\n\nFrom \nIserles et al., 'Lie-group methods' (2000)\n.\n\n\nAnother useful reference is \nPark and Chung, 'Geometric Integration on Euclidean Group with Application to Articulated Multibody Systems' (2005)\n.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.OdeIntegrators.OdeResultsSink\n \n \nType\n.\n\n\nabstract OdeResultsSink\n\n\n\n\nDoes 'something' with the results of an ODE integration (e.g. storing results, visualizing, etc.). Subtypes must implement:\n\n\n\n\ninitialize(sink, state)\n: called with the initial state when integration begins.\n\n\nprocess(sink, t, state)\n: called at every integration time step with the current state and time.\n\n\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.OdeIntegrators.RingBufferStorage\n \n \nType\n.\n\n\ntype RingBufferStorage{T} \n: RigidBodyDynamics.OdeIntegrators.OdeResultsSink\n\n\n\n\nAn \nOdeResultsSink\n that stores the state at each integration time step in a ring buffer.\n\n\nsource\n\n\n#\n\n\nBase.step\n \n \nMethod\n.\n\n\nstep(integrator, t, state, \u0394t)\n\n\n\n\n\nTake a single integration step.\n\n\nstate\n must be of a type for which the following functions are defined:\n\n\n\n\nconfiguration_vector(state)\n, returns the configuration vector in global coordinates.\n\n\nvelocity_vector(state)\n, returns the velocity vector.\n\n\nset_velocity!(state, v)\n, sets velocity vector to v.\n\n\nglobal_coordinates!(state, q0, \u03d5)\n, sets global coordinates in state based on local coordinates \n\u03d5\n centered around global coordinates \nq0\n.\n\n\nlocal_coordinates!(state, \u03d5, \u03d5d, q0)\n, converts state's global configuration \nq\n and velocity \nv\n to local coordinates centered around global coordinates \nq0\n.\n\n\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.OdeIntegrators.integrate\n \n \nMethod\n.\n\n\nintegrate(integrator, state0, finalTime, \u0394t)\n\n\n\n\n\nIntegrate dynamics from the initial state \nstate0\n at time $0$ to \nfinalTime\n using step size \n\u0394t\n.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.OdeIntegrators.runge_kutta_4\n \n \nMethod\n.\n\n\nrunge_kutta_4(scalartype)\n\n\n\n\n\nReturn the Butcher tableau for the standard fourth order Runge-Kutta integrator.\n\n\nsource\n\n\n#\n\n\nRigidBodyDynamics.OdeIntegrators.ButcherTableau\n \n \nType\n.\n\n\nimmutable ButcherTableau{N, T\n:Number, L}\n\n\n\n\nA \nButcher tableau\n.\n\n\nsource", 
            "title": "Simulation"
        }, 
        {
            "location": "/simulation/#simulation", 
            "text": "", 
            "title": "Simulation"
        }, 
        {
            "location": "/simulation/#index", 
            "text": "RigidBodyDynamics.OdeIntegrators.ButcherTableau  RigidBodyDynamics.OdeIntegrators.ExpandingStorage  RigidBodyDynamics.OdeIntegrators.MuntheKaasIntegrator  RigidBodyDynamics.OdeIntegrators.OdeResultsSink  RigidBodyDynamics.OdeIntegrators.RingBufferStorage  Base.step  RigidBodyDynamics.OdeIntegrators.integrate  RigidBodyDynamics.OdeIntegrators.runge_kutta_4  RigidBodyDynamics.simulate", 
            "title": "Index"
        }, 
        {
            "location": "/simulation/#basic-simulation", 
            "text": "#  RigidBodyDynamics.simulate     Function .  simulate(state0, finalTime; \u0394t)  Simple  Mechanism  simulation: integrate the state from time $0$ to  finalTime  starting from the initial state  state0 . Return a  Vector  of times, as well as  Vector s of configuration vectors and velocity vectors at these times.  Uses  MuntheKaasIntegrator . See  MuntheKaasIntegrator  for a lower level interface with more options.  source", 
            "title": "Basic simulation"
        }, 
        {
            "location": "/simulation/#lower-level-ode-integration-interface", 
            "text": "#  RigidBodyDynamics.OdeIntegrators.ExpandingStorage     Type .  type ExpandingStorage{T}  : RigidBodyDynamics.OdeIntegrators.OdeResultsSink  An  OdeResultsSink  that stores the state at each integration time step in  Vectors  that may expand.  source  #  RigidBodyDynamics.OdeIntegrators.MuntheKaasIntegrator     Type .  A Lie-group-aware ODE integrator.  MuntheKaasIntegrator  is used to properly integrate the dynamics of globally parameterized rigid joints (Duindam, Port-Based Modeling and Control for Efficient Bipedal Walking Robots, 2006, Definition 2.9). Global parameterizations of e.g. $SO(3)$ are needed to avoid singularities, but this leads to the problem that the tangent space no longer has the same dimension as the ambient space of the global parameterization. A Munthe-Kaas integrator solves this problem by converting back and forth between local and global coordinates at every integration time step.  The idea is to do the dynamics and compute the stages of the integration scheme in terms of local coordinates centered around the global parameterization of the configuration at the end of the previous time step (e.g. exponential coordinates), combine the stages into a new set of local coordinates as usual for Runge-Kutta methods, and then convert the local coordinates back to global coordinates.  From  Iserles et al., 'Lie-group methods' (2000) .  Another useful reference is  Park and Chung, 'Geometric Integration on Euclidean Group with Application to Articulated Multibody Systems' (2005) .  source  #  RigidBodyDynamics.OdeIntegrators.OdeResultsSink     Type .  abstract OdeResultsSink  Does 'something' with the results of an ODE integration (e.g. storing results, visualizing, etc.). Subtypes must implement:   initialize(sink, state) : called with the initial state when integration begins.  process(sink, t, state) : called at every integration time step with the current state and time.   source  #  RigidBodyDynamics.OdeIntegrators.RingBufferStorage     Type .  type RingBufferStorage{T}  : RigidBodyDynamics.OdeIntegrators.OdeResultsSink  An  OdeResultsSink  that stores the state at each integration time step in a ring buffer.  source  #  Base.step     Method .  step(integrator, t, state, \u0394t)  Take a single integration step.  state  must be of a type for which the following functions are defined:   configuration_vector(state) , returns the configuration vector in global coordinates.  velocity_vector(state) , returns the velocity vector.  set_velocity!(state, v) , sets velocity vector to v.  global_coordinates!(state, q0, \u03d5) , sets global coordinates in state based on local coordinates  \u03d5  centered around global coordinates  q0 .  local_coordinates!(state, \u03d5, \u03d5d, q0) , converts state's global configuration  q  and velocity  v  to local coordinates centered around global coordinates  q0 .   source  #  RigidBodyDynamics.OdeIntegrators.integrate     Method .  integrate(integrator, state0, finalTime, \u0394t)  Integrate dynamics from the initial state  state0  at time $0$ to  finalTime  using step size  \u0394t .  source  #  RigidBodyDynamics.OdeIntegrators.runge_kutta_4     Method .  runge_kutta_4(scalartype)  Return the Butcher tableau for the standard fourth order Runge-Kutta integrator.  source  #  RigidBodyDynamics.OdeIntegrators.ButcherTableau     Type .  immutable ButcherTableau{N, T :Number, L}  A  Butcher tableau .  source", 
            "title": "Lower level ODE integration interface"
        }, 
        {
            "location": "/benchmarks/", 
            "text": "Benchmarks\n\n\nRun \nperf/runbenchmarks.jl\n (\n-O3\n and \n--check-bounds=no\n flags recommended) to see benchmark results for the Atlas robot (v5) in the following scenarios:\n\n\n\n\nCompute the joint-space mass matrix.\n\n\nDo inverse dynamics.\n\n\nDo forward dynamics.\n\n\n\n\nNote that results on Travis builds are \nnot at all\n representative because of code coverage. Results on a recent, fast machine with version 0.0.4:\n\n\nOutput of \nversioninfo()\n:\n\n\nJulia Version 0.5.0\nCommit 3c9d753 (2016-09-19 18:14 UTC)\nPlatform Info:\n  System: Linux (x86_64-pc-linux-gnu)\n  CPU: Intel(R) Core(TM) i7-6950X CPU @ 3.00GHz\n  WORD_SIZE: 64\n  BLAS: libopenblas (USE64BITINT DYNAMIC_ARCH NO_AFFINITY Haswell)\n  LAPACK: libopenblas64_\n  LIBM: libopenlibm\n  LLVM: libLLVM-3.7.1 (ORCJIT, broadwell)\n\n\n\n\nMass matrix:\n\n\n  memory estimate:  0.00 bytes\n  allocs estimate:  0\n  --------------\n  minimum time:     23.034 \u03bcs (0.00% GC)\n  median time:      23.364 \u03bcs (0.00% GC)\n  mean time:        23.546 \u03bcs (0.00% GC)\n  maximum time:     52.605 \u03bcs (0.00% GC)\n  --------------\n  samples:          10000\n  evals/sample:     1\n  time tolerance:   5.00%\n  memory tolerance: 1.00%\n\n\n\n\nInverse dynamics:\n\n\n  memory estimate:  0.00 bytes\n  allocs estimate:  0\n  --------------\n  minimum time:     29.178 \u03bcs (0.00% GC)\n  median time:      29.704 \u03bcs (0.00% GC)\n  mean time:        30.276 \u03bcs (0.00% GC)\n  maximum time:     65.232 \u03bcs (0.00% GC)\n  --------------\n  samples:          10000\n  evals/sample:     1\n  time tolerance:   5.00%\n  memory tolerance: 1.00%\n\n\n\n\nForward dynamics:\n\n\n  memory estimate:  48.00 bytes\n  allocs estimate:  2\n  --------------\n  minimum time:     53.336 \u03bcs (0.00% GC)\n  median time:      82.928 \u03bcs (0.00% GC)\n  mean time:        83.334 \u03bcs (0.00% GC)\n  maximum time:     208.453 \u03bcs (0.00% GC)\n  --------------\n  samples:          10000\n  evals/sample:     1\n  time tolerance:   5.00%\n  memory tolerance: 1.00%", 
            "title": "Benchmarks"
        }, 
        {
            "location": "/benchmarks/#benchmarks", 
            "text": "Run  perf/runbenchmarks.jl  ( -O3  and  --check-bounds=no  flags recommended) to see benchmark results for the Atlas robot (v5) in the following scenarios:   Compute the joint-space mass matrix.  Do inverse dynamics.  Do forward dynamics.   Note that results on Travis builds are  not at all  representative because of code coverage. Results on a recent, fast machine with version 0.0.4:  Output of  versioninfo() :  Julia Version 0.5.0\nCommit 3c9d753 (2016-09-19 18:14 UTC)\nPlatform Info:\n  System: Linux (x86_64-pc-linux-gnu)\n  CPU: Intel(R) Core(TM) i7-6950X CPU @ 3.00GHz\n  WORD_SIZE: 64\n  BLAS: libopenblas (USE64BITINT DYNAMIC_ARCH NO_AFFINITY Haswell)\n  LAPACK: libopenblas64_\n  LIBM: libopenlibm\n  LLVM: libLLVM-3.7.1 (ORCJIT, broadwell)  Mass matrix:    memory estimate:  0.00 bytes\n  allocs estimate:  0\n  --------------\n  minimum time:     23.034 \u03bcs (0.00% GC)\n  median time:      23.364 \u03bcs (0.00% GC)\n  mean time:        23.546 \u03bcs (0.00% GC)\n  maximum time:     52.605 \u03bcs (0.00% GC)\n  --------------\n  samples:          10000\n  evals/sample:     1\n  time tolerance:   5.00%\n  memory tolerance: 1.00%  Inverse dynamics:    memory estimate:  0.00 bytes\n  allocs estimate:  0\n  --------------\n  minimum time:     29.178 \u03bcs (0.00% GC)\n  median time:      29.704 \u03bcs (0.00% GC)\n  mean time:        30.276 \u03bcs (0.00% GC)\n  maximum time:     65.232 \u03bcs (0.00% GC)\n  --------------\n  samples:          10000\n  evals/sample:     1\n  time tolerance:   5.00%\n  memory tolerance: 1.00%  Forward dynamics:    memory estimate:  48.00 bytes\n  allocs estimate:  2\n  --------------\n  minimum time:     53.336 \u03bcs (0.00% GC)\n  median time:      82.928 \u03bcs (0.00% GC)\n  mean time:        83.334 \u03bcs (0.00% GC)\n  maximum time:     208.453 \u03bcs (0.00% GC)\n  --------------\n  samples:          10000\n  evals/sample:     1\n  time tolerance:   5.00%\n  memory tolerance: 1.00%", 
            "title": "Benchmarks"
        }
    ]
}